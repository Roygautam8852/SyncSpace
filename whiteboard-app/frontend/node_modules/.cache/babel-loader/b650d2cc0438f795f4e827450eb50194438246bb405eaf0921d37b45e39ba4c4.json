{"ast":null,"code":"import * as s from \"react\";\nimport { useRef as ue, useMemo as Be, useCallback as ne, useEffect as Ve } from \"react\";\nimport { u as U, r as qe, a as De, b as je, c as Y, d as We, e as ze, f as ce, g as Ge, h as Je, i as fe, j as $e, k as Qe, m as Ke, G as Ye, n as Xe, o as Ze, p as me, q as et, t as tt, v as Ie, w as pe, x as Ne, y as nt, l as j, z as rt, A as st, B as he, C as ot, D as at, E as it, F as ct, H as ut, I as dt, J as lt, K as ft, M as Te, N as mt, O as pt, P as ht, Q as bt, S as vt, T as gt, U as St, V as yt, W as _e, X as Ct, Y as Mt, Z as Tt, _ as Et, $ as kt, a0 as wt, a1 as Pt, a2 as Lt, a3 as At, a4 as Rt, a5 as Ot, a6 as Dt, a7 as le, a8 as $, a9 as It, aa as Nt, ab as _t, ac as Ft, ad as xt } from \"./contexts-D4V9wQRc.mjs\";\nimport { m as Q } from \"./room-BP3SCCCd.mjs\";\nimport { ConnectionState as I, LocalTrackPublication as Ut, facingModeFromLocalTrack as Ht, Room as Fe, Track as E, createAudioAnalyser as be, ParticipantKind as ae, Mutex as Bt, ParticipantEvent as ee, RoomEvent as V, decodeTokenPayload as Vt, TokenSourceConfigurable as qt } from \"livekit-client\";\nconst jt = e => {\n  const n = s.useRef(e);\n  return s.useEffect(() => {\n    n.current = e;\n  }), n;\n};\nfunction Wt(e, n) {\n  const t = Gt(),\n    r = jt(n);\n  return s.useLayoutEffect(() => {\n    let o = !1;\n    const i = e.current;\n    if (!i) return;\n    function a(c, u) {\n      o || r.current(c, u);\n    }\n    return t == null || t.subscribe(i, a), () => {\n      o = !0, t == null || t.unsubscribe(i, a);\n    };\n  }, [e.current, t, r]), t == null ? void 0 : t.observer;\n}\nfunction zt() {\n  let e = !1,\n    n = [];\n  const t = /* @__PURE__ */new Map();\n  if (typeof window > \"u\") return;\n  const r = new ResizeObserver((o, i) => {\n    n = n.concat(o), e || window.requestAnimationFrame(() => {\n      const a = /* @__PURE__ */new Set();\n      for (let c = 0; c < n.length; c++) {\n        if (a.has(n[c].target)) continue;\n        a.add(n[c].target);\n        const u = t.get(n[c].target);\n        u == null || u.forEach(p => p(n[c], i));\n      }\n      n = [], e = !1;\n    }), e = !0;\n  });\n  return {\n    observer: r,\n    subscribe(o, i) {\n      r.observe(o);\n      const a = t.get(o) ?? [];\n      a.push(i), t.set(o, a);\n    },\n    unsubscribe(o, i) {\n      const a = t.get(o) ?? [];\n      if (a.length === 1) {\n        r.unobserve(o), t.delete(o);\n        return;\n      }\n      const c = a.indexOf(i);\n      c !== -1 && a.splice(c, 1), t.set(o, a);\n    }\n  };\n}\nlet de;\nconst Gt = () => de || (de = zt()),\n  Jt = e => {\n    const [n, t] = s.useState({\n      width: 0,\n      height: 0\n    });\n    s.useLayoutEffect(() => {\n      if (e.current) {\n        const {\n          width: o,\n          height: i\n        } = e.current.getBoundingClientRect();\n        t({\n          width: o,\n          height: i\n        });\n      }\n    }, [e.current]);\n    const r = s.useCallback(o => t(o.contentRect), []);\n    return Wt(e, r), n;\n  };\nfunction O(e, n, t = !0) {\n  const [r, o] = s.useState(n);\n  return s.useEffect(() => {\n    if (t && o(n), typeof window > \"u\" || !e) return;\n    const i = e.subscribe(o);\n    return () => i.unsubscribe();\n  }, [e, t]), r;\n}\nfunction Dn(e) {\n  const n = i => typeof window < \"u\" ? window.matchMedia(i).matches : !1,\n    [t, r] = s.useState(n(e));\n  function o() {\n    r(n(e));\n  }\n  return s.useEffect(() => {\n    const i = window.matchMedia(e);\n    return o(), i.addListener ? i.addListener(o) : i.addEventListener(\"change\", o), () => {\n      i.removeListener ? i.removeListener(o) : i.removeEventListener(\"change\", o);\n    };\n  }, [e]), t;\n}\nfunction In(e) {\n  const n = U(e),\n    t = s.useCallback(async () => {\n      await n.startAudio();\n    }, [n]),\n    r = s.useMemo(() => qe(n), [n]),\n    {\n      canPlayAudio: o\n    } = O(r, {\n      canPlayAudio: n.canPlaybackAudio\n    });\n  return {\n    canPlayAudio: o,\n    startAudio: t\n  };\n}\nfunction Nn(e) {\n  const {\n    state: n,\n    dispatch: t\n  } = De().pin;\n  return {\n    buttonProps: s.useMemo(() => {\n      const {\n        className: o\n      } = je();\n      return Q(e, {\n        className: o,\n        disabled: !(n != null && n.length),\n        onClick: () => {\n          t && t({\n            msg: \"clear_pin\"\n          });\n        }\n      });\n    }, [e, t, n])\n  };\n}\nfunction _n(e = {}) {\n  const n = Y(e.participant),\n    {\n      className: t,\n      connectionQualityObserver: r\n    } = s.useMemo(() => We(n), [n]),\n    o = O(r, n.connectionQuality);\n  return {\n    className: t,\n    quality: o\n  };\n}\nfunction re(e) {\n  const n = U(e),\n    t = s.useMemo(() => ze(n), [n]);\n  return O(t, n.state);\n}\nfunction Fn(e, n) {\n  const t = typeof e == \"function\" ? e : n,\n    r = typeof e == \"string\" ? e : void 0,\n    o = ce(),\n    {\n      send: i,\n      messageObservable: a,\n      isSendingObservable: c\n    } = s.useMemo(() => Ge(o, r, t), [o, r, t]),\n    u = O(a, void 0),\n    p = O(c, !1);\n  return {\n    message: u,\n    send: i,\n    isSending: p\n  };\n}\nfunction xn(e) {\n  const n = ce(),\n    t = re(n);\n  return {\n    buttonProps: s.useMemo(() => {\n      const {\n        className: o,\n        disconnect: i\n      } = Je(n);\n      return Q(e, {\n        className: o,\n        onClick: () => i(e.stopTracks ?? !0),\n        disabled: t === I.Disconnected\n      });\n    }, [n, e, t])\n  };\n}\nfunction $t(e) {\n  if (e.publication instanceof Ut) {\n    const n = e.publication.track;\n    if (n) {\n      const {\n        facingMode: t\n      } = Ht(n);\n      return t;\n    }\n  }\n  return \"undefined\";\n}\nfunction Un({\n  trackRef: e,\n  props: n\n}) {\n  const t = fe(e),\n    r = $e(),\n    {\n      className: o\n    } = s.useMemo(() => Qe(), []),\n    i = s.useMemo(() => Ke(t, r == null ? void 0 : r.pin.state), [t, r == null ? void 0 : r.pin.state]);\n  return {\n    mergedProps: s.useMemo(() => Q(n, {\n      className: o,\n      onClick: c => {\n        var u, p, h, l, d;\n        (u = n.onClick) == null || u.call(n, c), i ? (h = r == null ? void 0 : (p = r.pin).dispatch) == null || h.call(p, {\n          msg: \"clear_pin\"\n        }) : (d = r == null ? void 0 : (l = r.pin).dispatch) == null || d.call(l, {\n          msg: \"set_pin\",\n          trackReference: t\n        });\n      }\n    }), [n, o, t, i, r == null ? void 0 : r.pin]),\n    inFocus: i\n  };\n}\nfunction Hn(e, n, t = {}) {\n  const r = t.gridLayouts ?? Ye,\n    {\n      width: o,\n      height: i\n    } = Jt(e),\n    a = Xe(r, n, o, i);\n  return s.useEffect(() => {\n    e.current && a && (e.current.style.setProperty(\"--lk-col-count\", a == null ? void 0 : a.columns.toString()), e.current.style.setProperty(\"--lk-row-count\", a == null ? void 0 : a.rows.toString()));\n  }, [e, a]), {\n    layout: a,\n    containerWidth: o,\n    containerHeight: i\n  };\n}\nfunction Ee(e, n = {}) {\n  var c, u;\n  const t = typeof e == \"string\" ? n.participant : e.participant,\n    r = Y(t),\n    o = typeof e == \"string\" ? {\n      participant: r,\n      source: e\n    } : e,\n    [i, a] = s.useState(!!((c = o.publication) != null && c.isMuted || (u = r.getTrackPublication(o.source)) != null && u.isMuted));\n  return s.useEffect(() => {\n    const p = Ze(o).subscribe(a);\n    return () => p.unsubscribe();\n  }, [me(o)]), i;\n}\nfunction Qt(e) {\n  const n = Y(e),\n    t = s.useMemo(() => et(n), [n]);\n  return O(t, n.isSpeaking);\n}\nfunction xe(e = {}) {\n  const n = U(e.room),\n    [t, r] = s.useState(n.localParticipant),\n    [o, i] = s.useState(t.isMicrophoneEnabled),\n    [a, c] = s.useState(t.isCameraEnabled),\n    [u, p] = s.useState(t.isScreenShareEnabled),\n    [h, l] = s.useState(t.lastMicrophoneError),\n    [d, v] = s.useState(t.lastCameraError),\n    [M, w] = s.useState(void 0),\n    [A, P] = s.useState(void 0),\n    D = R => {\n      c(R.isCameraEnabled), i(R.isMicrophoneEnabled), p(R.isScreenShareEnabled), P(R.cameraTrack), w(R.microphoneTrack), l(R.participant.lastMicrophoneError), v(R.participant.lastCameraError), r(R.participant);\n    };\n  return s.useEffect(() => {\n    const R = tt(n.localParticipant).subscribe(D);\n    return () => R.unsubscribe();\n  }, [n]), {\n    isMicrophoneEnabled: o,\n    isScreenShareEnabled: u,\n    isCameraEnabled: a,\n    microphoneTrack: M,\n    cameraTrack: A,\n    lastMicrophoneError: h,\n    lastCameraError: d,\n    localParticipant: t\n  };\n}\nfunction Bn() {\n  const e = ce(),\n    n = s.useMemo(() => Ie(e.localParticipant), [e]);\n  return O(n, e.localParticipant.permissions);\n}\nfunction Vn({\n  kind: e,\n  room: n,\n  track: t,\n  requestPermissions: r,\n  onError: o\n}) {\n  const i = pe(),\n    a = s.useMemo(() => n ?? i ?? new Fe(), [n, i]),\n    c = s.useMemo(() => Ne(e, o, r), [e, r, o]),\n    u = O(c, []),\n    [p, h] = s.useState((a == null ? void 0 : a.getActiveDevice(e)) ?? \"default\"),\n    {\n      className: l,\n      activeDeviceObservable: d,\n      setActiveMediaDevice: v\n    } = s.useMemo(() => nt(e, a), [e, a, t]);\n  return s.useEffect(() => {\n    const M = d.subscribe(w => {\n      w && (j.info(\"setCurrentDeviceId\", w), h(w));\n    });\n    return () => {\n      M == null || M.unsubscribe();\n    };\n  }, [d]), {\n    devices: u,\n    className: l,\n    activeDeviceId: p,\n    setActiveMediaDevice: v\n  };\n}\nfunction qn({\n  kind: e,\n  onError: n\n}) {\n  const t = s.useMemo(() => Ne(e, n), [e, n]);\n  return O(t, []);\n}\nfunction Kt(e, n, t = {}) {\n  const r = s.useRef([]),\n    o = s.useRef(-1),\n    i = n !== o.current,\n    a = typeof t.customSortFunction == \"function\" ? t.customSortFunction(e) : rt(e);\n  let c = [...a];\n  if (i === !1) try {\n    c = st(r.current, a, n);\n  } catch (u) {\n    j.error(\"Error while running updatePages(): \", u);\n  }\n  return i ? r.current = a : r.current = c, o.current = n, c;\n}\nfunction jn(e, n) {\n  const [t, r] = s.useState(1),\n    o = Math.max(Math.ceil(n.length / e), 1);\n  t > o && r(o);\n  const i = t * e,\n    a = i - e,\n    c = l => {\n      r(d => l === \"next\" ? d === o ? d : d + 1 : d === 1 ? d : d - 1);\n    },\n    u = l => {\n      l > o ? r(o) : l < 1 ? r(1) : r(l);\n    },\n    h = Kt(n, e).slice(a, i);\n  return {\n    totalPageCount: o,\n    nextPage: () => c(\"next\"),\n    prevPage: () => c(\"previous\"),\n    setPage: u,\n    firstItemIndex: a,\n    lastItemIndex: i,\n    tracks: h,\n    currentPage: t\n  };\n}\nfunction Yt(e = {}) {\n  let n = he();\n  e.participant && (n = e.participant);\n  const t = s.useMemo(() => ot(n), [n]),\n    {\n      identity: r,\n      name: o,\n      metadata: i\n    } = O(t, {\n      name: n == null ? void 0 : n.name,\n      identity: n == null ? void 0 : n.identity,\n      metadata: n == null ? void 0 : n.metadata\n    });\n  return {\n    identity: r,\n    name: o,\n    metadata: i\n  };\n}\nfunction Wn(e = {}) {\n  const n = Y(e.participant),\n    t = s.useMemo(() => Ie(n), [n]);\n  return O(t, n.permissions);\n}\nfunction zn({\n  trackRef: e,\n  onParticipantClick: n,\n  disableSpeakingIndicator: t,\n  htmlProps: r\n}) {\n  const o = fe(e),\n    i = s.useMemo(() => {\n      const {\n        className: d\n      } = at();\n      return Q(r, {\n        className: d,\n        onClick: v => {\n          var M;\n          if ((M = r.onClick) == null || M.call(r, v), typeof n == \"function\") {\n            const w = o.publication ?? o.participant.getTrackPublication(o.source);\n            n({\n              participant: o.participant,\n              track: w\n            });\n          }\n        }\n      });\n    }, [r, n, o.publication, o.source, o.participant]),\n    a = o.participant.getTrackPublication(E.Source.Microphone),\n    c = s.useMemo(() => ({\n      participant: o.participant,\n      source: E.Source.Microphone,\n      publication: a\n    }), [a, o.participant]),\n    u = Ee(o),\n    p = Ee(c),\n    h = Qt(o.participant),\n    l = $t(o);\n  return {\n    elementProps: {\n      \"data-lk-audio-muted\": p,\n      \"data-lk-video-muted\": u,\n      \"data-lk-speaking\": t === !0 ? !1 : h,\n      \"data-lk-local-participant\": o.participant.isLocal,\n      \"data-lk-source\": o.source,\n      \"data-lk-facing-mode\": l,\n      ...i\n    }\n  };\n}\nfunction ve(e = {}) {\n  const n = U(e.room),\n    [t, r] = s.useState([]);\n  return s.useEffect(() => {\n    const o = it(n, {\n      additionalRoomEvents: e.updateOnlyOn\n    }).subscribe(r);\n    return () => o.unsubscribe();\n  }, [n, JSON.stringify(e.updateOnlyOn)]), t;\n}\nfunction Xt(e = {}) {\n  const n = ve(e),\n    {\n      localParticipant: t\n    } = xe(e);\n  return s.useMemo(() => [t, ...n], [t, n]);\n}\nfunction Gn(e) {\n  return e = ct(e), s.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);\n}\nfunction Jn(e, n = {}) {\n  const t = ce(),\n    [r] = s.useState(n.updateOnlyOn),\n    o = s.useMemo(() => typeof e == \"string\" ? ut(t, e, {\n      additionalEvents: r\n    }) : dt(t, e, {\n      additionalEvents: r\n    }), [t, JSON.stringify(e), r]),\n    [i, a] = s.useState({\n      p: void 0\n    });\n  return s.useEffect(() => {\n    const c = o.subscribe(u => a({\n      p: u\n    }));\n    return () => c.unsubscribe();\n  }, [o]), i.p;\n}\nfunction $n(e = {}) {\n  const n = U(e.room),\n    t = s.useMemo(() => lt(n), [n]),\n    {\n      name: r,\n      metadata: o\n    } = O(t, {\n      name: n.name,\n      metadata: n.metadata\n    });\n  return {\n    name: r,\n    metadata: o\n  };\n}\nfunction Zt(e) {\n  const n = U(e == null ? void 0 : e.room),\n    t = s.useMemo(() => ft(n), [n]);\n  return O(t, n.activeSpeakers);\n}\nfunction Qn(e) {\n  const [n, t] = s.useState(Te(e)),\n    r = Zt();\n  return s.useEffect(() => {\n    t(Te(e));\n  }, [r, e]), n;\n}\nfunction Kn({\n  room: e,\n  props: n\n}) {\n  const t = U(e),\n    {\n      className: r,\n      roomAudioPlaybackAllowedObservable: o,\n      handleStartAudioPlayback: i\n    } = s.useMemo(() => mt(), []),\n    a = s.useMemo(() => o(t), [t, o]),\n    {\n      canPlayAudio: c\n    } = O(a, {\n      canPlayAudio: t.canPlaybackAudio\n    });\n  return {\n    mergedProps: s.useMemo(() => Q(n, {\n      className: r,\n      onClick: () => {\n        i(t);\n      },\n      style: {\n        display: c ? \"none\" : \"block\"\n      }\n    }), [n, r, c, i, t]),\n    canPlayAudio: c\n  };\n}\nfunction Yn({\n  room: e,\n  props: n\n}) {\n  const t = U(e),\n    {\n      className: r,\n      roomVideoPlaybackAllowedObservable: o,\n      handleStartVideoPlayback: i\n    } = s.useMemo(() => pt(), []),\n    a = s.useMemo(() => o(t), [t, o]),\n    {\n      canPlayVideo: c\n    } = O(a, {\n      canPlayVideo: t.canPlaybackVideo\n    });\n  return {\n    mergedProps: s.useMemo(() => Q(n, {\n      className: r,\n      onClick: () => {\n        i(t);\n      },\n      style: {\n        display: c ? \"none\" : \"block\"\n      }\n    }), [n, r, c, i, t]),\n    canPlayVideo: c\n  };\n}\nfunction Xn(e, n = {}) {\n  const t = s.useRef(null),\n    r = s.useRef(null),\n    o = n.minSwipeDistance ?? 50,\n    i = u => {\n      r.current = null, t.current = u.targetTouches[0].clientX;\n    },\n    a = u => {\n      r.current = u.targetTouches[0].clientX;\n    },\n    c = s.useCallback(() => {\n      if (!t.current || !r.current) return;\n      const u = t.current - r.current,\n        p = u > o,\n        h = u < -o;\n      p && n.onLeftSwipe && n.onLeftSwipe(), h && n.onRightSwipe && n.onRightSwipe();\n    }, [o, n]);\n  s.useEffect(() => {\n    const u = e.current;\n    return u && (u.addEventListener(\"touchstart\", i, {\n      passive: !0\n    }), u.addEventListener(\"touchmove\", a, {\n      passive: !0\n    }), u.addEventListener(\"touchend\", c, {\n      passive: !0\n    })), () => {\n      u && (u.removeEventListener(\"touchstart\", i), u.removeEventListener(\"touchmove\", a), u.removeEventListener(\"touchend\", c));\n    };\n  }, [e, c]);\n}\nfunction Zn({\n  props: e\n}) {\n  const {\n      dispatch: n,\n      state: t\n    } = De().widget,\n    {\n      className: r\n    } = s.useMemo(() => ht(), []);\n  return {\n    mergedProps: s.useMemo(() => Q(e, {\n      className: r,\n      onClick: () => {\n        n && n({\n          msg: \"toggle_chat\"\n        });\n      },\n      \"aria-pressed\": t != null && t.showChat ? \"true\" : \"false\",\n      \"data-lk-unread-msgs\": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : \"9+\" : \"0\"\n    }), [e, r, n, t])\n  };\n}\nfunction er(e, n, t = {}) {\n  const [r, o] = s.useState(void 0);\n  return s.useEffect(() => {\n    var a;\n    if (e === void 0) throw Error(\"token endpoint needs to be defined\");\n    if (((a = t.userInfo) == null ? void 0 : a.identity) === void 0) return;\n    (async () => {\n      j.debug(\"fetching token\");\n      const c = new URLSearchParams({\n          ...t.userInfo,\n          roomName: n\n        }),\n        u = await fetch(`${e}?${c.toString()}`);\n      if (!u.ok) {\n        j.error(`Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`);\n        return;\n      }\n      const {\n        accessToken: p\n      } = await u.json();\n      o(p);\n    })();\n  }, [e, n, JSON.stringify(t)]), r;\n}\nfunction tr(e) {\n  var i, a;\n  const n = fe(e),\n    {\n      className: t,\n      mediaMutedObserver: r\n    } = s.useMemo(() => bt(n), [me(n)]);\n  return {\n    isMuted: O(r, !!((i = n.publication) != null && i.isMuted || (a = n.participant.getTrackPublication(n.source)) != null && a.isMuted)),\n    className: t\n  };\n}\nfunction nr({\n  source: e,\n  onChange: n,\n  initialState: t,\n  captureOptions: r,\n  publishOptions: o,\n  onDeviceError: i,\n  room: a,\n  ...c\n}) {\n  var m;\n  const u = pe(),\n    p = s.useMemo(() => a ?? u, [a, u]),\n    h = (m = p == null ? void 0 : p.localParticipant) == null ? void 0 : m.getTrackPublication(e),\n    l = s.useRef(!1),\n    {\n      toggle: d,\n      className: v,\n      pendingObserver: M,\n      enabledObserver: w\n    } = s.useMemo(() => p ? vt(e, p, r, o, i) : gt(), [p, e, JSON.stringify(r), o]),\n    A = O(M, !1),\n    P = O(w, t ?? !!(h != null && h.isEnabled));\n  s.useEffect(() => {\n    n == null || n(P, l.current), l.current = !1;\n  }, [P, n]), s.useEffect(() => {\n    t !== void 0 && (j.debug(\"forcing initial toggle state\", e, t), d(t));\n  }, []);\n  const D = s.useMemo(() => Q(c, {\n      className: v\n    }), [c, v]),\n    R = s.useCallback(f => {\n      var b;\n      l.current = !0, d().catch(() => l.current = !1), (b = c.onClick) == null || b.call(c, f);\n    }, [c, d]);\n  return {\n    toggle: d,\n    enabled: P,\n    pending: A,\n    track: h,\n    buttonProps: {\n      ...D,\n      \"aria-pressed\": P,\n      \"data-lk-source\": e,\n      \"data-lk-enabled\": P,\n      disabled: A,\n      onClick: R\n    }\n  };\n}\nfunction rr(e = [E.Source.Camera, E.Source.Microphone, E.Source.ScreenShare, E.Source.ScreenShareAudio, E.Source.Unknown], n = {}) {\n  const t = U(n.room),\n    [r, o] = s.useState([]),\n    [i, a] = s.useState([]),\n    c = s.useMemo(() => e.map(p => St(p) ? p.source : p), [JSON.stringify(e)]);\n  return s.useEffect(() => {\n    const p = yt(t, c, {\n      additionalRoomEvents: n.updateOnlyOn,\n      onlySubscribed: n.onlySubscribed\n    }).subscribe(({\n      trackReferences: h,\n      participants: l\n    }) => {\n      j.debug(\"setting track bundles\", h, l), o(h), a(l);\n    });\n    return () => p.unsubscribe();\n  }, [t, JSON.stringify(n.onlySubscribed), JSON.stringify(n.updateOnlyOn), JSON.stringify(e)]), s.useMemo(() => {\n    if (_e(e)) {\n      const p = tn(e, i),\n        h = Array.from(r);\n      return i.forEach(l => {\n        p.has(l.identity) && (p.get(l.identity) ?? []).forEach(v => {\n          if (r.find(({\n            participant: w,\n            publication: A\n          }) => l.identity === w.identity && A.source === v)) return;\n          j.debug(`Add ${v} placeholder for participant ${l.identity}.`);\n          const M = {\n            participant: l,\n            source: v\n          };\n          h.push(M);\n        });\n      }), h;\n    } else return r;\n  }, [r, i, e]);\n}\nfunction en(e, n) {\n  const t = new Set(e);\n  for (const r of n) t.delete(r);\n  return t;\n}\nfunction tn(e, n) {\n  const t = /* @__PURE__ */new Map();\n  if (_e(e)) {\n    const r = e.filter(o => o.withPlaceholder).map(o => o.source);\n    n.forEach(o => {\n      const i = o.getTrackPublications().map(c => {\n          var u;\n          return (u = c.track) == null ? void 0 : u.source;\n        }).filter(c => c !== void 0),\n        a = Array.from(en(new Set(r), new Set(i)));\n      a.length > 0 && t.set(o.identity, a);\n    });\n  }\n  return t;\n}\nfunction nn(e) {\n  const [n, t] = s.useState(Ct(e)),\n    {\n      trackObserver: r\n    } = s.useMemo(() => Mt(e), [e.participant.sid ?? e.participant.identity, e.source]);\n  return s.useEffect(() => {\n    const o = r.subscribe(i => {\n      t(i);\n    });\n    return () => o == null ? void 0 : o.unsubscribe();\n  }, [r]), {\n    participant: e.participant,\n    source: e.source ?? E.Source.Unknown,\n    publication: n\n  };\n}\nfunction sr(e, n) {\n  const t = Y(n);\n  return nn({\n    name: e,\n    participant: t\n  });\n}\nfunction rn(e) {\n  const n = U(e == null ? void 0 : e.room),\n    t = re(n),\n    r = s.useMemo(() => t === I.Disconnected, [t]),\n    o = s.useMemo(() => Tt(n, e), [n, e, r]),\n    i = O(o.isSendingObservable, !1),\n    a = O(o.messageObservable, []);\n  return {\n    send: o.send,\n    chatMessages: a,\n    isSending: i\n  };\n}\nfunction or(e = {}) {\n  const [n, t] = s.useState(Et(e.defaults, e.preventLoad ?? !1)),\n    r = s.useCallback(u => {\n      t(p => ({\n        ...p,\n        audioEnabled: u\n      }));\n    }, []),\n    o = s.useCallback(u => {\n      t(p => ({\n        ...p,\n        videoEnabled: u\n      }));\n    }, []),\n    i = s.useCallback(u => {\n      t(p => ({\n        ...p,\n        audioDeviceId: u\n      }));\n    }, []),\n    a = s.useCallback(u => {\n      t(p => ({\n        ...p,\n        videoDeviceId: u\n      }));\n    }, []),\n    c = s.useCallback(u => {\n      t(p => ({\n        ...p,\n        username: u\n      }));\n    }, []);\n  return s.useEffect(() => {\n    kt(n, e.preventSave ?? !1);\n  }, [n, e.preventSave]), {\n    userChoices: n,\n    saveAudioInputEnabled: r,\n    saveVideoInputEnabled: o,\n    saveAudioInputDeviceId: i,\n    saveVideoInputDeviceId: a,\n    saveUsername: c\n  };\n}\nfunction ar(e, n = {}) {\n  const t = Y(e),\n    r = U(n.room),\n    o = s.useMemo(() => wt(r, t), [r, t]);\n  return O(o, t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted));\n}\nfunction ir(e, n = {\n  fftSize: 32,\n  smoothingTimeConstant: 0\n}) {\n  const t = Pt(e) ? e.publication.track : e,\n    [r, o] = s.useState(0);\n  return s.useEffect(() => {\n    if (!t || !t.mediaStream) return;\n    const {\n        cleanup: i,\n        analyser: a\n      } = be(t, n),\n      c = a.frequencyBinCount,\n      u = new Uint8Array(c),\n      h = setInterval(() => {\n        a.getByteFrequencyData(u);\n        let l = 0;\n        for (let d = 0; d < u.length; d++) {\n          const v = u[d];\n          l += v * v;\n        }\n        o(Math.sqrt(l / u.length) / 255);\n      }, 1e3 / 30);\n    return () => {\n      i(), clearInterval(h);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), r;\n}\nconst sn = e => {\n    const n = t => {\n      let i = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;\n      return i = Math.sqrt(i), i;\n    };\n    return e.map(t => t === -1 / 0 ? 0 : n(t));\n  },\n  on = {\n    bands: 5,\n    loPass: 100,\n    hiPass: 600,\n    updateInterval: 32,\n    analyserOptions: {\n      fftSize: 2048\n    }\n  };\nfunction cr(e, n = {}) {\n  var a;\n  const t = e instanceof E ? e : (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track,\n    r = {\n      ...on,\n      ...n\n    },\n    [o, i] = s.useState(new Array(r.bands).fill(0));\n  return s.useEffect(() => {\n    if (!t || !(t != null && t.mediaStream)) {\n      i(v => v.slice().fill(0));\n      return;\n    }\n    const {\n        analyser: c,\n        cleanup: u\n      } = be(t, r.analyserOptions),\n      p = c.frequencyBinCount,\n      h = new Float32Array(p),\n      d = setInterval(() => {\n        c.getFloatFrequencyData(h);\n        let v = new Float32Array(h.length);\n        for (let P = 0; P < h.length; P++) v[P] = h[P];\n        v = v.slice(r.loPass, r.hiPass);\n        const M = sn(v),\n          w = M.length,\n          A = [];\n        for (let P = 0; P < r.bands; P++) {\n          const D = Math.floor(P * w / r.bands),\n            R = Math.floor((P + 1) * w / r.bands),\n            m = M.slice(D, R),\n            f = m.length;\n          if (f === 0) A.push(0);else {\n            const b = m.reduce((g, y) => g += y, 0);\n            A.push(b / f);\n          }\n        }\n        i(A);\n      }, r.updateInterval);\n    return () => {\n      u(), clearInterval(d);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), o;\n}\nconst an = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20\n};\nfunction ur(e, n = {}) {\n  var h;\n  const t = e instanceof E ? e : (h = e == null ? void 0 : e.publication) == null ? void 0 : h.track,\n    r = {\n      ...an,\n      ...n\n    },\n    o = s.useRef(new Float32Array()),\n    i = s.useRef(performance.now()),\n    a = s.useRef(0),\n    [c, u] = s.useState([]),\n    p = s.useCallback(l => {\n      u(Array.from(un(l, r.barCount).map(d => Math.sqrt(d) * r.volMultiplier)\n      // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ));\n    }, []);\n  return s.useEffect(() => {\n    if (!t || !(t != null && t.mediaStream)) return;\n    const {\n        analyser: l,\n        cleanup: d\n      } = be(t, {\n        fftSize: ke(r.barCount)\n      }),\n      v = ke(r.barCount),\n      M = new Float32Array(v),\n      w = () => {\n        if (A = requestAnimationFrame(w), l.getFloatTimeDomainData(M), o.current.map((P, D) => P + M[D]), a.current += 1, performance.now() - i.current >= r.updateInterval) {\n          const P = M.map(D => D / a.current);\n          p(P), i.current = performance.now(), a.current = 0;\n        }\n      };\n    let A = requestAnimationFrame(w);\n    return () => {\n      d(), cancelAnimationFrame(A);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), p]), {\n    bars: c\n  };\n}\nfunction ke(e) {\n  return e < 32 ? 32 : cn(e);\n}\nfunction cn(e) {\n  let n = 2;\n  for (; e >>= 1;) n <<= 1;\n  return n;\n}\nfunction un(e, n) {\n  const t = Math.floor(e.length / n),\n    r = new Float32Array(n);\n  for (let o = 0; o < n; o++) {\n    const i = t * o;\n    let a = 0;\n    for (let c = 0; c < t; c++) a = a + Math.abs(e[i + c]);\n    r[o] = a / t;\n  }\n  return r;\n}\nfunction ie(e, n = {}) {\n  let t, r;\n  typeof n == \"string\" ? t = n : (t = n == null ? void 0 : n.participantIdentity, r = n == null ? void 0 : n.room);\n  const o = he(),\n    i = Xt({\n      room: r,\n      updateOnlyOn: []\n    }),\n    a = s.useMemo(() => t ? i.find(p => p.identity === t) : o, [t, i, o]),\n    c = s.useMemo(() => {\n      if (a) return Lt(a, {\n        sources: e\n      });\n    }, [a, JSON.stringify(e)]);\n  return O(c, []);\n}\nfunction dn(e) {\n  var t, r, o;\n  const n = s.useMemo(() => {\n    var i;\n    return (i = e == null ? void 0 : e.publication) != null && i.track ? At(e == null ? void 0 : e.publication.track) : void 0;\n  }, [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]);\n  return O(n, {\n    timestamp: Date.now(),\n    rtpTimestamp: (o = (r = e == null ? void 0 : e.publication) == null ? void 0 : r.track) == null ? void 0 : o.rtpTimestamp\n  });\n}\nconst ln = {\n  bufferSize: 100\n  // maxAge: 2_000,\n};\nfunction fn(e, n) {\n  const t = {\n      ...ln,\n      ...n\n    },\n    [r, o] = s.useState([]),\n    i = dn(e),\n    a = c => {\n      var u;\n      (u = t.onTranscription) == null || u.call(t, c), o(p => Ot(p,\n      // when first receiving a segment, add the current media timestamp to it\n      c.map(h => Dt(h, i)), t.bufferSize));\n    };\n  return s.useEffect(() => {\n    if (!(e != null && e.publication)) return;\n    const c = Rt(e.publication).subscribe(u => {\n      a(...u);\n    });\n    return () => {\n      c.unsubscribe();\n    };\n  }, [e && me(e), a]), {\n    segments: r\n  };\n}\nfunction mn(e = {}) {\n  const n = he(),\n    t = e.participant ?? n,\n    r = s.useMemo(\n    // weird typescript constraint\n    () => t ? le(t) : le(t), [t]);\n  return O(r, {\n    attributes: t == null ? void 0 : t.attributes\n  });\n}\nfunction dr(e, n = {}) {\n  const t = Y(n.participant),\n    [r, o] = s.useState(t.attributes[e]);\n  return s.useEffect(() => {\n    if (!t) return;\n    const i = le(t).subscribe(a => {\n      a.changed[e] !== void 0 && o(a.attributes[e]);\n    });\n    return () => {\n      i.unsubscribe();\n    };\n  }, [t, e]), r;\n}\nconst we = $.AgentState;\nfunction lr() {\n  const e = ve(),\n    n = e.find(l => l.kind === ae.AGENT && !($.PublishOnBehalf in l.attributes)),\n    t = e.find(l => l.kind === ae.AGENT && l.attributes[$.PublishOnBehalf] === (n == null ? void 0 : n.identity)),\n    r = ie([E.Source.Microphone, E.Source.Camera], n == null ? void 0 : n.identity),\n    o = ie([E.Source.Microphone, E.Source.Camera], t == null ? void 0 : t.identity),\n    i = r.find(l => l.source === E.Source.Microphone) ?? o.find(l => l.source === E.Source.Microphone),\n    a = r.find(l => l.source === E.Source.Camera) ?? o.find(l => l.source === E.Source.Camera),\n    {\n      segments: c\n    } = fn(i),\n    u = re(),\n    {\n      attributes: p\n    } = mn({\n      participant: n\n    }),\n    h = s.useMemo(() => u === I.Disconnected ? \"disconnected\" : u === I.Connecting || !n || !(p != null && p[we]) ? \"connecting\" : p[we], [p, n, u]);\n  return {\n    agent: n,\n    state: h,\n    audioTrack: i,\n    videoTrack: a,\n    agentTranscriptions: c,\n    agentAttributes: p\n  };\n}\nfunction fr(e) {\n  const n = U(e),\n    t = re(n),\n    r = s.useMemo(() => It(n), [n, t]);\n  return O(r, n.isRecording);\n}\nfunction pn(e, n) {\n  const t = U(n == null ? void 0 : n.room),\n    o = re(t) === I.Disconnected,\n    i = s.useMemo(() => Nt(t, e), [t, e]);\n  return {\n    textStreams: O(o ? void 0 : i, [])\n  };\n}\nfunction hn(e) {\n  const {\n      participantIdentities: n,\n      trackSids: t\n    } = e ?? {},\n    {\n      textStreams: r\n    } = pn(_t.TRANSCRIPTION, {\n      room: e == null ? void 0 : e.room\n    });\n  return s.useMemo(() => r.filter(i => n ? n.includes(i.participantInfo.identity) : !0).filter(i => {\n    var a;\n    return t ? t.includes(((a = i.streamInfo.attributes) == null ? void 0 : a[$.TranscribedTrackId]) ?? \"\") : !0;\n  }), [r, n, t]);\n}\nconst Pe = 2,\n  Le = 400,\n  Ae = 3,\n  Re = 1e3;\nfunction mr(e) {\n  const n = ue([]),\n    t = Be(() => new Bt(), []),\n    r = ne(async () => t.lock().then(async h => {\n      for (;;) {\n        const l = n.current.pop();\n        if (!l) {\n          h();\n          break;\n        }\n        switch (l.type) {\n          case \"connect\":\n            await l.room.connect(...l.args).then(l.resolve).catch(l.reject);\n            break;\n          case \"disconnect\":\n            await l.room.disconnect(...l.args).then(l.resolve).catch(l.reject);\n            break;\n        }\n      }\n    }), []),\n    o = ue([]),\n    i = ne(h => {\n      let l = 0;\n      o.current = o.current.filter(d => {\n        const v = h.getTime() - d.getTime() < Re;\n        return v && (l += 1), v;\n      }), l > Ae && j.warn(`useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${Ae}x in ${Re}ms). This is not recommended.`);\n    }, []);\n  Ve(() => {\n    n.current = [];\n    const h = /* @__PURE__ */new Date();\n    o.current.push(h), i(h);\n  }, [e, i]);\n  const a = ue([]),\n    c = ne(h => {\n      let l = 0;\n      a.current = a.current.filter(d => {\n        const v = h.getTime() - d.getTime() < Le;\n        return v && (l += 1), v;\n      }), l > Pe && j.warn(`useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${Pe}x in ${Le}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`);\n    }, []),\n    u = ne(async (...h) => new Promise((l, d) => {\n      if (!e) throw new Error(\"Called connect(), but room was unset\");\n      const v = /* @__PURE__ */new Date();\n      c(v), n.current.push({\n        type: \"connect\",\n        room: e,\n        args: h,\n        resolve: l,\n        reject: d\n      }), a.current.push(v), r();\n    }), [e, c, r]),\n    p = ne(async (...h) => new Promise((l, d) => {\n      if (!e) throw new Error(\"Called discconnect(), but room was unset\");\n      const v = /* @__PURE__ */new Date();\n      c(v), n.current.push({\n        type: \"disconnect\",\n        room: e,\n        args: h,\n        resolve: l,\n        reject: d\n      }), a.current.push(v), r();\n    }), [e, c, r]);\n  return {\n    connect: e ? u : null,\n    disconnect: e ? p : null\n  };\n}\nvar oe = {\n    exports: {}\n  },\n  Oe;\nfunction bn() {\n  if (Oe) return oe.exports;\n  Oe = 1;\n  var e = typeof Reflect == \"object\" ? Reflect : null,\n    n = e && typeof e.apply == \"function\" ? e.apply : function (f, b, g) {\n      return Function.prototype.apply.call(f, b, g);\n    },\n    t;\n  e && typeof e.ownKeys == \"function\" ? t = e.ownKeys : Object.getOwnPropertySymbols ? t = function (f) {\n    return Object.getOwnPropertyNames(f).concat(Object.getOwnPropertySymbols(f));\n  } : t = function (f) {\n    return Object.getOwnPropertyNames(f);\n  };\n  function r(m) {\n    console && console.warn && console.warn(m);\n  }\n  var o = Number.isNaN || function (f) {\n    return f !== f;\n  };\n  function i() {\n    i.init.call(this);\n  }\n  oe.exports = i, oe.exports.once = P, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;\n  var a = 10;\n  function c(m) {\n    if (typeof m != \"function\") throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof m);\n  }\n  Object.defineProperty(i, \"defaultMaxListeners\", {\n    enumerable: !0,\n    get: function () {\n      return a;\n    },\n    set: function (m) {\n      if (typeof m != \"number\" || m < 0 || o(m)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + m + \".\");\n      a = m;\n    }\n  }), i.init = function () {\n    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n  }, i.prototype.setMaxListeners = function (f) {\n    if (typeof f != \"number\" || f < 0 || o(f)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + f + \".\");\n    return this._maxListeners = f, this;\n  };\n  function u(m) {\n    return m._maxListeners === void 0 ? i.defaultMaxListeners : m._maxListeners;\n  }\n  i.prototype.getMaxListeners = function () {\n    return u(this);\n  }, i.prototype.emit = function (f) {\n    for (var b = [], g = 1; g < arguments.length; g++) b.push(arguments[g]);\n    var y = f === \"error\",\n      T = this._events;\n    if (T !== void 0) y = y && T.error === void 0;else if (!y) return !1;\n    if (y) {\n      var C;\n      if (b.length > 0 && (C = b[0]), C instanceof Error) throw C;\n      var k = new Error(\"Unhandled error.\" + (C ? \" (\" + C.message + \")\" : \"\"));\n      throw k.context = C, k;\n    }\n    var F = T[f];\n    if (F === void 0) return !1;\n    if (typeof F == \"function\") n(F, this, b);else for (var B = F.length, H = M(F, B), g = 0; g < B; ++g) n(H[g], this, b);\n    return !0;\n  };\n  function p(m, f, b, g) {\n    var y, T, C;\n    if (c(b), T = m._events, T === void 0 ? (T = m._events = /* @__PURE__ */Object.create(null), m._eventsCount = 0) : (T.newListener !== void 0 && (m.emit(\"newListener\", f, b.listener ? b.listener : b), T = m._events), C = T[f]), C === void 0) C = T[f] = b, ++m._eventsCount;else if (typeof C == \"function\" ? C = T[f] = g ? [b, C] : [C, b] : g ? C.unshift(b) : C.push(b), y = u(m), y > 0 && C.length > y && !C.warned) {\n      C.warned = !0;\n      var k = new Error(\"Possible EventEmitter memory leak detected. \" + C.length + \" \" + String(f) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      k.name = \"MaxListenersExceededWarning\", k.emitter = m, k.type = f, k.count = C.length, r(k);\n    }\n    return m;\n  }\n  i.prototype.addListener = function (f, b) {\n    return p(this, f, b, !1);\n  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function (f, b) {\n    return p(this, f, b, !0);\n  };\n  function h() {\n    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n  }\n  function l(m, f, b) {\n    var g = {\n        fired: !1,\n        wrapFn: void 0,\n        target: m,\n        type: f,\n        listener: b\n      },\n      y = h.bind(g);\n    return y.listener = b, g.wrapFn = y, y;\n  }\n  i.prototype.once = function (f, b) {\n    return c(b), this.on(f, l(this, f, b)), this;\n  }, i.prototype.prependOnceListener = function (f, b) {\n    return c(b), this.prependListener(f, l(this, f, b)), this;\n  }, i.prototype.removeListener = function (f, b) {\n    var g, y, T, C, k;\n    if (c(b), y = this._events, y === void 0) return this;\n    if (g = y[f], g === void 0) return this;\n    if (g === b || g.listener === b) --this._eventsCount === 0 ? this._events = /* @__PURE__ */Object.create(null) : (delete y[f], y.removeListener && this.emit(\"removeListener\", f, g.listener || b));else if (typeof g != \"function\") {\n      for (T = -1, C = g.length - 1; C >= 0; C--) if (g[C] === b || g[C].listener === b) {\n        k = g[C].listener, T = C;\n        break;\n      }\n      if (T < 0) return this;\n      T === 0 ? g.shift() : w(g, T), g.length === 1 && (y[f] = g[0]), y.removeListener !== void 0 && this.emit(\"removeListener\", f, k || b);\n    }\n    return this;\n  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function (f) {\n    var b, g, y;\n    if (g = this._events, g === void 0) return this;\n    if (g.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */Object.create(null), this._eventsCount = 0) : g[f] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */Object.create(null) : delete g[f]), this;\n    if (arguments.length === 0) {\n      var T = Object.keys(g),\n        C;\n      for (y = 0; y < T.length; ++y) C = T[y], C !== \"removeListener\" && this.removeAllListeners(C);\n      return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */Object.create(null), this._eventsCount = 0, this;\n    }\n    if (b = g[f], typeof b == \"function\") this.removeListener(f, b);else if (b !== void 0) for (y = b.length - 1; y >= 0; y--) this.removeListener(f, b[y]);\n    return this;\n  };\n  function d(m, f, b) {\n    var g = m._events;\n    if (g === void 0) return [];\n    var y = g[f];\n    return y === void 0 ? [] : typeof y == \"function\" ? b ? [y.listener || y] : [y] : b ? A(y) : M(y, y.length);\n  }\n  i.prototype.listeners = function (f) {\n    return d(this, f, !0);\n  }, i.prototype.rawListeners = function (f) {\n    return d(this, f, !1);\n  }, i.listenerCount = function (m, f) {\n    return typeof m.listenerCount == \"function\" ? m.listenerCount(f) : v.call(m, f);\n  }, i.prototype.listenerCount = v;\n  function v(m) {\n    var f = this._events;\n    if (f !== void 0) {\n      var b = f[m];\n      if (typeof b == \"function\") return 1;\n      if (b !== void 0) return b.length;\n    }\n    return 0;\n  }\n  i.prototype.eventNames = function () {\n    return this._eventsCount > 0 ? t(this._events) : [];\n  };\n  function M(m, f) {\n    for (var b = new Array(f), g = 0; g < f; ++g) b[g] = m[g];\n    return b;\n  }\n  function w(m, f) {\n    for (; f + 1 < m.length; f++) m[f] = m[f + 1];\n    m.pop();\n  }\n  function A(m) {\n    for (var f = new Array(m.length), b = 0; b < f.length; ++b) f[b] = m[b].listener || m[b];\n    return f;\n  }\n  function P(m, f) {\n    return new Promise(function (b, g) {\n      function y(C) {\n        m.removeListener(f, T), g(C);\n      }\n      function T() {\n        typeof m.removeListener == \"function\" && m.removeListener(\"error\", y), b([].slice.call(arguments));\n      }\n      R(m, f, T, {\n        once: !0\n      }), f !== \"error\" && D(m, y, {\n        once: !0\n      });\n    });\n  }\n  function D(m, f, b) {\n    typeof m.on == \"function\" && R(m, \"error\", f, b);\n  }\n  function R(m, f, b, g) {\n    if (typeof m.on == \"function\") g.once ? m.once(f, b) : m.on(f, b);else if (typeof m.addEventListener == \"function\") m.addEventListener(f, function y(T) {\n      g.once && m.removeEventListener(f, y), b(T);\n    });else throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof m);\n  }\n  return oe.exports;\n}\nvar ge = bn();\nconst vn = 2e4;\nvar gn = /* @__PURE__ */(e => (e.CameraChanged = \"cameraChanged\", e.MicrophoneChanged = \"microphoneChanged\", e.StateChanged = \"stateChanged\", e))(gn || {});\nconst x = e => ({\n    isConnected: e === \"listening\" || e === \"thinking\" || e === \"speaking\",\n    canListen: e === \"pre-connect-buffering\" || e === \"listening\" || e === \"thinking\" || e === \"speaking\",\n    isFinished: e === \"disconnected\" || e === \"failed\",\n    isPending: e === \"connecting\" || e === \"initializing\" || e === \"idle\"\n  }),\n  Sn = () => {\n    const [e, n] = s.useState(null),\n      [t, r] = s.useState(null),\n      o = s.useRef(\"connecting\"),\n      i = s.useRef(!1),\n      a = c => setTimeout(() => {\n        if (!i.current) {\n          n(\"Agent did not join the room.\");\n          return;\n        }\n        const {\n          isConnected: u\n        } = x(o.current);\n        if (!u) {\n          n(\"Agent joined the room but did not complete initializing.\");\n          return;\n        }\n      }, c ?? vn);\n    return {\n      agentTimeoutFailureReason: e,\n      startAgentTimeout: s.useCallback(c => {\n        t && clearTimeout(t), n(null), r(a(c)), o.current = \"connecting\", i.current = !1;\n      }, [t]),\n      clearAgentTimeout: s.useCallback(() => {\n        t && clearTimeout(t), n(null), r(null), o.current = \"connecting\", i.current = !1;\n      }, [t]),\n      clearAgentTimeoutFailureReason: s.useCallback(() => {\n        n(null);\n      }, []),\n      updateAgentTimeoutState: s.useCallback(c => {\n        o.current = c;\n      }, []),\n      updateAgentTimeoutParticipantExists: s.useCallback(c => {\n        i.current = c;\n      }, [])\n    };\n  };\nfunction yn(e, n) {\n  const t = s.useRef(n);\n  s.useEffect(() => {\n    t.current = n;\n  }, [n]);\n  const r = s.useCallback(async a => {\n      const {\n        isConnected: c\n      } = x(t.current);\n      if (!c) return new Promise((u, p) => {\n        const h = v => {\n            const {\n              isConnected: M\n            } = x(v);\n            M && (d(), u());\n          },\n          l = () => {\n            d(), p(new Error(\"useAgent(/* ... */).waitUntilConnected - signal aborted\"));\n          },\n          d = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", l);\n          };\n        e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", l);\n      });\n    }, [e]),\n    o = s.useCallback(async a => {\n      const {\n        canListen: c\n      } = x(t.current);\n      if (!c) return new Promise((u, p) => {\n        const h = v => {\n            const {\n              canListen: M\n            } = x(v);\n            M && (d(), u());\n          },\n          l = () => {\n            d(), p(new Error(\"useAgent(/* ... */).waitUntilCouldBeListening - signal aborted\"));\n          },\n          d = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", l);\n          };\n        e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", l);\n      });\n    }, [e]),\n    i = s.useCallback(async a => {\n      const {\n        isFinished: c\n      } = x(t.current);\n      if (!c) return new Promise((u, p) => {\n        const h = v => {\n            const {\n              isFinished: M\n            } = x(v);\n            M && (d(), u());\n          },\n          l = () => {\n            d(), p(new Error(\"useAgent(/* ... */).waitUntilFinished - signal aborted\"));\n          },\n          d = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", l);\n          };\n        e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", l);\n      });\n    }, [e]);\n  return {\n    waitUntilConnected: r,\n    waitUntilCouldBeListening: o,\n    waitUntilFinished: i\n  };\n}\nfunction Ue(e) {\n  const n = Ft();\n  if (e = e ?? n, !e) throw new Error(\"No session provided, make sure you are inside a Session context or pass the session explicitly\");\n  const {\n      room: t,\n      internal: {\n        agentConnectTimeoutMilliseconds: r,\n        agentTimeoutFailureReason: o,\n        startAgentTimeout: i,\n        clearAgentTimeout: a,\n        clearAgentTimeoutFailureReason: c,\n        updateAgentTimeoutState: u,\n        updateAgentTimeoutParticipantExists: p\n      }\n    } = e,\n    h = s.useMemo(() => new ge.EventEmitter(), []),\n    l = ve({\n      room: t\n    }),\n    d = s.useMemo(() => l.find(S => S.kind === ae.AGENT && !($.PublishOnBehalf in S.attributes)) ?? null, [l]),\n    v = s.useMemo(() => d ? l.find(S => S.kind === ae.AGENT && S.attributes[$.PublishOnBehalf] === d.identity) ?? null : null, [d, l]),\n    [M, w] = s.useState((d == null ? void 0 : d.attributes) ?? {});\n  s.useEffect(() => {\n    if (!d) return;\n    const S = _ => {\n      w(_);\n    };\n    return d.on(ee.AttributesChanged, S), () => {\n      d.off(ee.AttributesChanged, S);\n    };\n  }, [d, h]);\n  const A = ie([E.Source.Camera, E.Source.Microphone], {\n      room: t,\n      participantIdentity: d == null ? void 0 : d.identity\n    }),\n    P = ie([E.Source.Camera, E.Source.Microphone], {\n      room: t,\n      participantIdentity: v == null ? void 0 : v.identity\n    }),\n    D = s.useMemo(() => A.find(S => S.source === E.Source.Camera) ?? P.find(S => S.source === E.Source.Camera), [A, P]);\n  s.useEffect(() => {\n    h.emit(\"cameraChanged\", D);\n  }, [h, D]);\n  const R = s.useMemo(() => A.find(S => S.source === E.Source.Microphone) ?? P.find(S => S.source === E.Source.Microphone), [A, P]);\n  s.useEffect(() => {\n    h.emit(\"microphoneChanged\", R);\n  }, [h, R]);\n  const [m, f] = s.useState(t.state);\n  s.useEffect(() => {\n    const S = _ => {\n      f(_);\n    };\n    return t.on(V.ConnectionStateChanged, S), () => {\n      t.off(V.ConnectionStateChanged, S);\n    };\n  }, [t]), s.useEffect(() => {\n    d && c();\n  }, [d]);\n  const [b, g] = s.useState(null);\n  s.useEffect(() => {\n    if (!d) return;\n    const S = _ => {\n      _.identity === (d == null ? void 0 : d.identity) && g(\"Agent left the room unexpectedly.\");\n    };\n    return t.on(V.ParticipantDisconnected, S), () => {\n      t.off(V.ParticipantDisconnected, S);\n    };\n  }, [d, t]), s.useEffect(() => {\n    m === I.Disconnected && g(null);\n  }, [m]);\n  const [y, T] = s.useState(() => t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null);\n  s.useEffect(() => {\n    const S = () => {\n        T(t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null);\n      },\n      _ = () => {\n        T(null);\n      };\n    return t.localParticipant.on(ee.LocalTrackPublished, S), t.localParticipant.on(ee.LocalTrackUnpublished, _), () => {\n      t.localParticipant.off(ee.LocalTrackPublished, S), t.localParticipant.off(ee.LocalTrackUnpublished, _);\n    };\n  }, [t.localParticipant]);\n  const C = s.useMemo(() => {\n      const S = [];\n      return o && S.push(o), b && S.push(b), S;\n    }, [o, b]),\n    k = s.useMemo(() => {\n      if (C.length > 0) return \"failed\";\n      let S = \"disconnected\";\n      return m !== I.Disconnected && (S = \"connecting\"), y && (S = \"pre-connect-buffering\"), d && M[$.AgentState] && (S = M[$.AgentState]), S;\n    }, [C, m, y, d, M]);\n  s.useEffect(() => {\n    h.emit(\"stateChanged\", k), u(k);\n  }, [h, k]), s.useEffect(() => {\n    p(d !== null);\n  }, [d]);\n  const F = e.connectionState === \"disconnected\";\n  s.useEffect(() => {\n    if (!F) return i(r), () => {\n      a();\n    };\n  }, [F, r]);\n  const {\n      identity: B,\n      name: H,\n      metadata: K\n    } = Yt({\n      participant: d ?? void 0\n    }),\n    te = s.useMemo(() => {\n      const S = {\n        attributes: M,\n        internal: {\n          agentParticipant: d,\n          workerParticipant: v,\n          emitter: h\n        }\n      };\n      switch (k) {\n        case \"disconnected\":\n          return {\n            ...S,\n            identity: void 0,\n            name: void 0,\n            metadata: void 0,\n            state: k,\n            ...x(k),\n            failureReasons: null,\n            // Clear inner values if no longer connected\n            cameraTrack: void 0,\n            microphoneTrack: void 0\n          };\n        case \"connecting\":\n          return {\n            ...S,\n            identity: void 0,\n            name: void 0,\n            metadata: void 0,\n            state: k,\n            ...x(k),\n            failureReasons: null,\n            // Clear inner values if no longer connected\n            cameraTrack: void 0,\n            microphoneTrack: void 0\n          };\n        case \"initializing\":\n        case \"idle\":\n          return {\n            ...S,\n            identity: B,\n            name: H,\n            metadata: K,\n            state: k,\n            ...x(k),\n            failureReasons: null,\n            cameraTrack: D,\n            microphoneTrack: R\n          };\n        case \"pre-connect-buffering\":\n          return {\n            ...S,\n            identity: B,\n            name: H,\n            metadata: K,\n            state: k,\n            ...x(k),\n            failureReasons: null,\n            cameraTrack: D,\n            microphoneTrack: R\n          };\n        case \"listening\":\n        case \"thinking\":\n        case \"speaking\":\n          return {\n            ...S,\n            identity: B,\n            name: H,\n            metadata: K,\n            state: k,\n            ...x(k),\n            failureReasons: null,\n            cameraTrack: D,\n            microphoneTrack: R\n          };\n        case \"failed\":\n          return {\n            ...S,\n            identity: void 0,\n            name: void 0,\n            metadata: void 0,\n            state: \"failed\",\n            ...x(\"failed\"),\n            failureReasons: C,\n            // Clear inner values if no longer connected\n            cameraTrack: void 0,\n            microphoneTrack: void 0\n          };\n      }\n    }, [B, H, K, M, h, d, k, D, R]),\n    {\n      waitUntilConnected: X,\n      waitUntilCouldBeListening: L,\n      waitUntilFinished: N\n    } = yn(h, k),\n    q = s.useCallback(S => new Promise((_, Z) => {\n      const W = J => {\n          J && (G(), _(J));\n        },\n        z = () => {\n          G(), Z(new Error(\"useAgent(/* ... */).waitUntilCamera - signal aborted\"));\n        },\n        G = () => {\n          h.off(\"cameraChanged\", W), S == null || S.removeEventListener(\"abort\", z);\n        };\n      h.on(\"cameraChanged\", W), S == null || S.addEventListener(\"abort\", z);\n    }), [h]),\n    se = s.useCallback(S => new Promise((_, Z) => {\n      const W = J => {\n          J && (G(), _(J));\n        },\n        z = () => {\n          G(), Z(new Error(\"useAgent(/* ... */).waitUntilMicrophone - signal aborted\"));\n        },\n        G = () => {\n          h.off(\"microphoneChanged\", W), S == null || S.removeEventListener(\"abort\", z);\n        };\n      h.on(\"microphoneChanged\", W), S == null || S.addEventListener(\"abort\", z);\n    }), [h]);\n  return s.useMemo(() => ({\n    ...te,\n    waitUntilConnected: X,\n    waitUntilCouldBeListening: L,\n    waitUntilFinished: N,\n    waitUntilCamera: q,\n    waitUntilMicrophone: se\n  }), [te, X, L, N, q, se]);\n}\nvar Cn = /* @__PURE__ */(e => (e.ConnectionStateChanged = \"connectionStateChanged\", e.MediaDevicesError = \"mediaDevicesError\", e.EncryptionError = \"encryptionError\", e))(Cn || {});\nfunction Mn(e, n) {\n  const t = /* @__PURE__ */new Set([...Object.keys(e), ...Object.keys(n)]);\n  for (const r of t) switch (r) {\n    case \"roomName\":\n    case \"participantName\":\n    case \"participantIdentity\":\n    case \"participantMetadata\":\n    case \"participantAttributes\":\n    case \"agentName\":\n    case \"agentMetadata\":\n      if (e[r] !== n[r]) return !1;\n      break;\n    default:\n      const o = r;\n      throw new Error(`Options key ${o} not being checked for equality!`);\n  }\n  return !0;\n}\nfunction Tn(e, n) {\n  const t = s.useRef(n);\n  return s.useEffect(() => {\n    t.current = n;\n  }, [n]), s.useCallback(async (o, i) => {\n    if (t.current !== o) return new Promise((a, c) => {\n      const u = l => {\n          l === o && (h(), a());\n        },\n        p = () => {\n          h(), c(new Error(`useSession(/* ... */).waitUntilConnectionState(${o}, /* signal */) - signal aborted`));\n        },\n        h = () => {\n          e.off(\"connectionStateChanged\", u), i == null || i.removeEventListener(\"abort\", p);\n        };\n      e.on(\"connectionStateChanged\", u), i == null || i.addEventListener(\"abort\", p);\n    });\n  }, [e]);\n}\nfunction En(e, n) {\n  const t = e instanceof qt,\n    r = s.useRef(t ? n : null);\n  return s.useEffect(() => {\n    if (!t) {\n      r.current = null;\n      return;\n    }\n    r.current !== null && Mn(r.current, n) || (r.current = n);\n  }, [t, n]), s.useCallback(async () => {\n    if (t) {\n      if (!r.current) throw new Error(\"AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!\");\n      return e.fetch(r.current);\n    } else return e.fetch();\n  }, [t, e]);\n}\nfunction pr(e, n = {}) {\n  const {\n      room: t,\n      agentConnectTimeoutMilliseconds: r,\n      ...o\n    } = n,\n    i = pe(),\n    a = s.useMemo(() => i ?? t ?? new Fe(), [i, t]),\n    c = s.useMemo(() => new ge.EventEmitter(), []),\n    u = s.useCallback(L => ({\n      isConnected: L === I.Connected || L === I.Reconnecting || L === I.SignalReconnecting\n    }), []),\n    [p, h] = s.useState(a.state);\n  s.useEffect(() => {\n    const L = N => {\n      h(N);\n    };\n    return a.on(V.ConnectionStateChanged, L), () => {\n      a.off(V.ConnectionStateChanged, L);\n    };\n  }, [a]), s.useEffect(() => {\n    const L = async N => {\n      c.emit(\"mediaDevicesError\", N);\n    };\n    return a.on(V.MediaDevicesError, L), () => {\n      a.off(V.MediaDevicesError, L);\n    };\n  }, [a, c]), s.useEffect(() => {\n    const L = async N => {\n      c.emit(\"encryptionError\", N);\n    };\n    return a.on(V.EncryptionError, L), () => {\n      a.off(V.EncryptionError, L);\n    };\n  }, [a, c]);\n  const {\n      localParticipant: l\n    } = xe({\n      room: a\n    }),\n    d = l.getTrackPublication(E.Source.Camera),\n    v = s.useMemo(() => {\n      if (d) return {\n        source: E.Source.Camera,\n        participant: l,\n        publication: d\n      };\n    }, [l, d]),\n    M = l.getTrackPublication(E.Source.Microphone),\n    w = s.useMemo(() => {\n      if (M) return {\n        source: E.Source.Microphone,\n        participant: l,\n        publication: M\n      };\n    }, [l, M]),\n    A = l.getTrackPublication(E.Source.ScreenShare),\n    P = s.useMemo(() => {\n      if (A) return {\n        source: E.Source.ScreenShare,\n        participant: l,\n        publication: A\n      };\n    }, [l, A]),\n    {\n      agentTimeoutFailureReason: D,\n      startAgentTimeout: R,\n      clearAgentTimeout: m,\n      clearAgentTimeoutFailureReason: f,\n      updateAgentTimeoutState: b,\n      updateAgentTimeoutParticipantExists: g\n    } = Sn(),\n    y = s.useMemo(() => ({\n      emitter: c,\n      tokenSource: e,\n      agentConnectTimeoutMilliseconds: r,\n      agentTimeoutFailureReason: D,\n      startAgentTimeout: R,\n      clearAgentTimeout: m,\n      clearAgentTimeoutFailureReason: f,\n      updateAgentTimeoutState: b,\n      updateAgentTimeoutParticipantExists: g\n    }), [c, r, e, D, R, m, f, b, g]),\n    T = s.useMemo(() => {\n      const L = {\n        room: a,\n        internal: y\n      };\n      switch (p) {\n        case I.Connecting:\n          return {\n            ...L,\n            connectionState: I.Connecting,\n            ...u(I.Connecting),\n            local: {\n              cameraTrack: void 0,\n              microphoneTrack: void 0,\n              screenShareTrack: void 0\n            }\n          };\n        case I.Connected:\n        case I.Reconnecting:\n        case I.SignalReconnecting:\n          return {\n            ...L,\n            connectionState: p,\n            ...u(p),\n            local: {\n              cameraTrack: v,\n              microphoneTrack: w,\n              screenShareTrack: P\n            }\n          };\n        case I.Disconnected:\n          return {\n            ...L,\n            connectionState: I.Disconnected,\n            ...u(I.Disconnected),\n            local: {\n              cameraTrack: void 0,\n              microphoneTrack: void 0,\n              screenShareTrack: void 0\n            }\n          };\n      }\n    }, [y, a, p, v, w, u]);\n  s.useEffect(() => {\n    c.emit(\"connectionStateChanged\", T.connectionState);\n  }, [c, T.connectionState]);\n  const C = Tn(c, T.connectionState),\n    k = s.useCallback(async L => C(I.Connected, L), [C]),\n    F = s.useCallback(async L => C(I.Disconnected, L), [C]),\n    B = Ue(s.useMemo(() => ({\n      connectionState: T.connectionState,\n      room: a,\n      internal: y\n    }), [T, a, y])),\n    H = En(e, o),\n    K = s.useCallback(async (L = {}) => {\n      var Z, W, z, G, J, Se;\n      const {\n        signal: N,\n        tracks: q = {\n          microphone: {\n            enabled: !0,\n            publishOptions: {\n              preConnectBuffer: !0\n            }\n          }\n        },\n        roomConnectOptions: se\n      } = L;\n      await F(N);\n      const S = () => {\n        a.disconnect();\n      };\n      N == null || N.addEventListener(\"abort\", S);\n      let _ = !1;\n      await Promise.all([H().then(({\n        serverUrl: He,\n        participantToken: ye\n      }) => {\n        var Ce, Me;\n        return _ = (((Me = (Ce = Vt(ye).roomConfig) == null ? void 0 : Ce.agents) == null ? void 0 : Me.length) ?? 0) > 0, a.connect(He, ye, se);\n      }),\n      // Start microphone (with preconnect buffer) by default\n      (Z = q.microphone) != null && Z.enabled ? a.localParticipant.setMicrophoneEnabled(!0, void 0, ((W = q.microphone) == null ? void 0 : W.publishOptions) ?? {}) : Promise.resolve(), (z = q.camera) != null && z.enabled ? a.localParticipant.setCameraEnabled(!0, void 0, ((G = q.camera) == null ? void 0 : G.publishOptions) ?? {}) : Promise.resolve(), (J = q.screenShare) != null && J.enabled ? a.localParticipant.setScreenShareEnabled(!0, void 0, ((Se = q.screenShare) == null ? void 0 : Se.publishOptions) ?? {}) : Promise.resolve()]), await k(N), _ && (await B.waitUntilConnected(N)), N == null || N.removeEventListener(\"abort\", S);\n    }, [a, F, H, k, B.waitUntilConnected]),\n    te = s.useCallback(async () => {\n      await a.disconnect();\n    }, [a]),\n    X = s.useCallback(async () => {\n      const L = await H();\n      await a.prepareConnection(L.serverUrl, L.participantToken);\n    }, [H, a]);\n  return s.useEffect(() => {\n    X().catch(L => {\n      console.warn(\"WARNING: Room.prepareConnection failed:\", L);\n    });\n  }, [\n    /* note: no prepareConnection here, this effect should only ever run once! */\n  ]), s.useMemo(() => ({\n    ...T,\n    waitUntilConnected: k,\n    waitUntilDisconnected: F,\n    prepareConnection: X,\n    start: K,\n    end: te\n  }), [T, k, F, X, K, te]);\n}\nfunction hr(e, n, t, r) {\n  const o = s.useMemo(() => () => {}, []),\n    i = s.useCallback(t ?? o, r ?? []),\n    a = r ? i : t,\n    c = s.useMemo(() => e ? \"internal\" in e ? e.internal.emitter : e : null, [e]);\n  s.useEffect(() => {\n    if (!(!c || !a)) return c.on(n, a), () => {\n      c.off(n, a);\n    };\n  }, [c, n, a]);\n}\nvar kn = /* @__PURE__ */(e => (e.MessageReceived = \"messageReceived\", e))(kn || {});\nfunction br(e) {\n  const {\n      room: n\n    } = xt(e),\n    t = s.useMemo(() => new ge.EventEmitter(), []),\n    r = Ue(e),\n    o = hn({\n      room: n\n    }),\n    i = s.useMemo(() => ({\n      room: n\n    }), [n]),\n    a = rn(i),\n    c = s.useMemo(() => o.map(d => {\n      var v, M, w;\n      switch (d.participantInfo.identity) {\n        case n.localParticipant.identity:\n          return {\n            type: \"userTranscript\",\n            message: d.text,\n            id: d.streamInfo.id,\n            timestamp: d.streamInfo.timestamp,\n            from: n.localParticipant\n          };\n        case (v = r.internal.agentParticipant) == null ? void 0 : v.identity:\n        case (M = r.internal.workerParticipant) == null ? void 0 : M.identity:\n          return {\n            type: \"agentTranscript\",\n            message: d.text,\n            id: d.streamInfo.id,\n            timestamp: d.streamInfo.timestamp,\n            from: ((w = r.internal.agentParticipant) == null ? void 0 : w.identity) === d.participantInfo.identity ? r.internal.agentParticipant : r.internal.workerParticipant\n          };\n        default:\n          return {\n            type: \"agentTranscript\",\n            message: d.text,\n            id: d.streamInfo.id,\n            timestamp: d.streamInfo.timestamp,\n            from: Array.from(n.remoteParticipants.values()).find(A => A.identity === d.participantInfo.identity)\n          };\n      }\n    }), [o, n]),\n    u = s.useMemo(() => [...c, ...a.chatMessages], [c, a.chatMessages]),\n    p = s.useRef(/* @__PURE__ */new Map()),\n    h = s.useMemo(() => {\n      const d = /* @__PURE__ */new Date();\n      for (const v of u) p.current.has(v.id) || p.current.set(v.id, d);\n      return u.sort((v, M) => {\n        const w = p.current.get(v.id),\n          A = p.current.get(M.id);\n        return typeof w > \"u\" || typeof A > \"u\" ? 0 : w.getTime() - A.getTime();\n      });\n    }, [u]),\n    l = s.useRef(/* @__PURE__ */new Set());\n  return s.useEffect(() => {\n    for (const d of h) l.current.has(d.id) || (l.current.add(d.id), t.emit(\"messageReceived\", d));\n  }, [h]), s.useMemo(() => ({\n    messages: h,\n    send: a.send,\n    isSending: a.isSending,\n    internal: {\n      emitter: t\n    }\n  }), [h, a.send, a.isSending]);\n}\nexport { pn as $, Bn as A, Gn as B, xe as C, In as D, Fn as E, $t as F, Ee as G, Qt as H, Yt as I, Wn as J, Xt as K, Jn as L, ve as M, Qn as N, Zt as O, er as P, sr as Q, gn as R, Ue as S, ir as T, ur as U, ie as V, fn as W, lr as X, mn as Y, dr as Z, fr as _, re as a, hn as a0, mr as a1, Cn as a2, pr as a3, hr as a4, kn as a5, br as a6, Zn as b, xn as c, Un as d, Vn as e, Kn as f, Yn as g, nr as h, _n as i, O as j, tr as k, zn as l, ar as m, Hn as n, jn as o, Xn as p, Jt as q, Kt as r, cr as s, rr as t, Nn as u, $n as v, rn as w, or as x, qn as y, Dn as z };","map":{"version":3,"names":["jt","e","n","s","useRef","useEffect","current","Wt","t","Gt","r","useLayoutEffect","o","i","a","c","u","subscribe","unsubscribe","observer","zt","Map","window","ResizeObserver","concat","requestAnimationFrame","Set","length","has","target","add","get","forEach","p","observe","push","set","unobserve","delete","indexOf","splice","de","getResizeObserver","Jt","useState","width","height","getBoundingClientRect","useCallback","contentRect","O","Dn","matchMedia","matches","addListener","addEventListener","removeListener","removeEventListener","In","U","startAudio","useMemo","qe","canPlayAudio","canPlaybackAudio","Nn","state","dispatch","De","pin","buttonProps","className","je","Q","disabled","onClick","msg","_n","Y","participant","connectionQualityObserver","We","connectionQuality","quality","re","ze","Fn","ce","send","messageObservable","isSendingObservable","Ge","message","isSending","xn","disconnect","Je","stopTracks","I","Disconnected","$t","publication","Ut","track","facingMode","Ht","Un","trackRef","props","fe","$e","Qe","Ke","mergedProps","call","h","d","l","trackReference","inFocus","Hn","gridLayouts","Ye","Xe","style","setProperty","columns","toString","rows","layout","containerWidth","containerHeight","Ee","source","isMuted","getTrackPublication","Ze","me","Qt","et","isSpeaking","xe","room","localParticipant","isMicrophoneEnabled","isCameraEnabled","isScreenShareEnabled","lastMicrophoneError","v","lastCameraError","M","w","A","P","D","R","cameraTrack","microphoneTrack","tt","Bn","Ie","permissions","Vn","kind","requestPermissions","onError","pe","Fe","Ne","getActiveDevice","activeDeviceObservable","setActiveMediaDevice","nt","j","info","devices","activeDeviceId","qn","Kt","customSortFunction","rt","st","error","jn","Math","max","ceil","slice","totalPageCount","nextPage","prevPage","setPage","firstItemIndex","lastItemIndex","tracks","currentPage","Yt","he","ot","identity","name","metadata","Wn","zn","onParticipantClick","disableSpeakingIndicator","htmlProps","at","E","Source","Microphone","elementProps","isLocal","ve","it","additionalRoomEvents","updateOnlyOn","JSON","stringify","Xt","Gn","ct","Jn","ut","additionalEvents","dt","$n","lt","Zt","ft","activeSpeakers","Qn","Te","Kn","roomAudioPlaybackAllowedObservable","handleStartAudioPlayback","mt","display","Yn","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","pt","canPlayVideo","canPlaybackVideo","Xn","minSwipeDistance","targetTouches","clientX","onLeftSwipe","onRightSwipe","passive","Zn","widget","ht","showChat","unreadMessages","toFixed","er","Error","userInfo","debug","URLSearchParams","roomName","fetch","ok","status","statusText","accessToken","json","tr","mediaMutedObserver","bt","nr","onChange","initialState","captureOptions","publishOptions","onDeviceError","m","toggle","pendingObserver","enabledObserver","vt","gt","isEnabled","f","catch","b","enabled","pending","rr","Camera","ScreenShare","ScreenShareAudio","Unknown","map","St","yt","onlySubscribed","trackReferences","participants","_e","tn","Array","from","find","en","filter","withPlaceholder","getTrackPublications","nn","Ct","trackObserver","Mt","sid","sr","rn","Tt","chatMessages","or","Et","defaults","preventLoad","audioEnabled","videoEnabled","audioDeviceId","videoDeviceId","username","kt","preventSave","userChoices","saveAudioInputEnabled","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","ar","wt","isE2EEEnabled","isEncrypted","ir","fftSize","smoothingTimeConstant","Pt","mediaStream","cleanup","analyser","be","frequencyBinCount","Uint8Array","setInterval","getByteFrequencyData","sqrt","clearInterval","sn","min","on","bands","loPass","hiPass","updateInterval","analyserOptions","cr","fill","Float32Array","getFloatFrequencyData","floor","reduce","g","y","an","barCount","volMultiplier","ur","performance","now","un","ke","update","getFloatTimeDomainData","cancelAnimationFrame","bars","cn","abs","ie","participantIdentity","Lt","sources","dn","At","timestamp","Date","rtpTimestamp","ln","bufferSize","fn","onTranscription","Ot","Dt","Rt","segments","mn","le","attributes","dr","changed","we","$","AgentState","lr","ae","AGENT","PublishOnBehalf","Connecting","agent","audioTrack","videoTrack","agentTranscriptions","agentAttributes","fr","It","isRecording","pn","Nt","textStreams","hn","participantIdentities","trackSids","_t","TRANSCRIPTION","includes","participantInfo","streamInfo","TranscribedTrackId","Pe","Le","Ae","Re","mr","ue","Be","Bt","ne","lock","then","pop","type","connect","args","resolve","reject","getTime","warn","Ve","Promise","Reflect","apply","Function","prototype","ownKeys","Object","getOwnPropertySymbols","ReflectOwnKeys","getOwnPropertyNames","console","Number","isNaN","init","oe","exports","once","EventEmitter","_events","_eventsCount","_maxListeners","TypeError","defineProperty","enumerable","RangeError","getPrototypeOf","create","setMaxListeners","defaultMaxListeners","getMaxListeners","emit","arguments","T","C","k","context","F","B","H","newListener","listener","unshift","warned","String","emitter","count","prependListener","fired","wrapFn","bind","prependOnceListener","shift","off","removeAllListeners","keys","listeners","rawListeners","listenerCount","eventNames","vn","gn","CameraChanged","MicrophoneChanged","StateChanged","x","isConnected","canListen","isFinished","isPending","Sn","useAgentTimeoutIdStore","setTimeout","agentTimeoutFailureReason","startAgentTimeout","clearTimeout","clearAgentTimeout","clearAgentTimeoutFailureReason","updateAgentTimeoutState","updateAgentTimeoutParticipantExists","yn","abortHandler","waitUntilConnected","waitUntilCouldBeListening","waitUntilFinished","Ue","Ft","internal","agentConnectTimeoutMilliseconds","ge","S","_","ee","AttributesChanged","V","ConnectionStateChanged","ParticipantDisconnected","handleLocalParticipantTrackPublished","handleLocalParticipantTrackUnPublished","LocalTrackPublished","LocalTrackUnpublished","connectionState","K","te","agentParticipant","workerParticipant","failureReasons","X","L","N","q","Z","W","J","G","z","se","waitUntilCamera","waitUntilMicrophone","Cn","MediaDevicesError","EncryptionError","Mn","Tn","En","qt","pr","Connected","Reconnecting","SignalReconnecting","tokenSource","local","screenShareTrack","signal","microphone","preConnectBuffer","roomConnectOptions","onSignalAbort","all","serverUrl","He","participantToken","ye","Me","Ce","Vt","roomConfig","agents","setMicrophoneEnabled","camera","setCameraEnabled","screenShare","setScreenShareEnabled","Se","prepareConnection","waitUntilDisconnected","start","end","hr","kn","MessageReceived","br","xt","text","id","remoteParticipants","values","sort","messages"],"sources":["D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useResizeObserver.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useObservableState.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useMediaQuery.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useAudioPlayback.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useClearPinButton.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useConnectionQualityIndicator.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useConnectionStatus.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useDataChannel.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useDisconnectButton.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useFacingMode.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useFocusToggle.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useGridLayout.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsMuted.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsSpeaking.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useLocalParticipant.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useLocalParticipantPermissions.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useMediaDeviceSelect.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useMediaDevices.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useVisualStableUpdate.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\usePagination.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantInfo.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantPermissions.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantTile.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useRemoteParticipants.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipants.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\usePinnedTracks.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useRemoteParticipant.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useRoomInfo.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSpeakingParticipants.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSortedParticipants.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useStartAudio.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useStartVideo.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSwipe.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useChatToggle.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useToken.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackMutedIndicator.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackToggle.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTracks.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackRefBySourceOrName.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackByName.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useChat.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\usePersistentUserChoices.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsEncrypted.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackVolume.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantTracks.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackSyncTime.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackTranscription.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantAttributes.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useVoiceAssistant.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsRecording.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTextStream.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useTranscriptions.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSequentialRoomConnectDisconnect.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\node_modules\\.pnpm\\events@3.3.0\\node_modules\\events\\events.js","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useAgent.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSession.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useEvents.ts","D:\\CapstoneProject\\whiteboard-app\\frontend\\node_modules\\@livekit\\components-react\\src\\hooks\\useSessionMessages.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\n\nconst useLatest = <T>(current: T) => {\n  const storedValue = React.useRef(current);\n  React.useEffect(() => {\n    storedValue.current = current;\n  });\n  return storedValue;\n};\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(\n  observable: Observable<T> | undefined,\n  startWith: T,\n  resetWhenObservableChanges = true,\n) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    if (resetWhenObservableChanges) {\n      setState(startWith);\n    }\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable, resetWhenObservableChanges]);\n  return state;\n}\n","import * as React from 'react';\n/**\n * Implementation used from https://github.com/juliencrn/usehooks-ts\n *\n * @internal\n */\nexport function useMediaQuery(query: string): boolean {\n  const getMatches = (query: string): boolean => {\n    // Prevents SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  };\n\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\n\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n\n  React.useEffect(() => {\n    const matchMedia = window.matchMedia(query);\n\n    // Triggered at the first client-side load and if query changes\n    handleChange();\n\n    // Listen matchMedia\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener('change', handleChange);\n    }\n\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener('change', handleChange);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n\n  return matches;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, p.connectionQuality);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton(buttonProps);\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\n  }, [trackReference, layoutContext?.pin.state]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (inFocus) {\n            layoutContext?.pin.dispatch?.({\n              msg: 'clear_pin',\n            });\n          } else {\n            layoutContext?.pin.dispatch?.({\n              msg: 'set_pin',\n              trackReference,\n            });\n          }\n        },\n      }),\n    [props, className, trackReference, inFocus, layoutContext?.pin],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n  options: {\n    gridLayouts?: GridLayoutDefinition[];\n  } = {},\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\n  const { width, height } = useSize(gridElement);\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n    containerWidth: width,\n    containerHeight: height,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example With a track reference\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n *\n * @param trackRef - A `TrackReference` indicating the track to monitor.\n * @returns boolean indicating if the track is muted\n *\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(localParticipant.isCameraEnabled);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isScreenShareEnabled,\n  );\n\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\n\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\n    roomFallback?.getActiveDevice(kind) ?? 'default',\n  );\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, roomFallback),\n    [kind, roomFallback, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      if (!deviceId) {\n        return;\n      }\n      log.info('setCurrentDeviceId', deviceId);\n      setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({\n  kind,\n  onError,\n}: {\n  kind: MediaDeviceKind;\n  onError?: (e: Error) => void;\n}) {\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError),\n    [kind, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\nimport { Track } from 'livekit-client';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrackPublication(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\n  const micRef = React.useMemo(() => {\n    return {\n      participant: trackReference.participant,\n      source: Track.Source.Microphone,\n      publication: micTrack,\n    };\n  }, [micTrack, trackReference.participant]);\n  const isVideoMuted = useIsMuted(trackReference);\n  const isAudioMuted = useIsMuted(micRef);\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { Room } from 'livekit-client';\n\n/** @public */\nexport type UseSpeakingParticipantsOptions = {\n  room?: Room;\n};\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants(options?: UseSpeakingParticipantsOptions) {\n  const ensuredRoom = useEnsureRoom(options?.room);\n\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(ensuredRoom), [ensuredRoom]);\n  const activeSpeakers = useObservableState(speakerObserver, ensuredRoom.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { useObservableState } from './internal';\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(trackReference),\n    [getTrackReferenceId(trackReference)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(\n      trackReference.publication?.isMuted ||\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\n    ),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport { type Room } from 'livekit-client';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {\n  room?: Room;\n}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  publishOptions,\n  onDeviceError,\n  room,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const roomFromContext = useMaybeRoomContext();\n  const roomFallback = React.useMemo(() => room ?? roomFromContext, [room, roomFromContext]);\n  const track = roomFallback?.localParticipant?.getTrackPublication(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () =>\n      roomFallback\n        ? setupMediaToggle<T>(source, roomFallback, captureOptions, publishOptions, onDeviceError)\n        : setupManualToggle(),\n    [roomFallback, source, JSON.stringify(captureOptions), publishOptions],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().catch(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n    ? TrackReferenceOrPlaceholder[]\n    : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [\n    room,\n    JSON.stringify(options.onlySubscribed),\n    JSON.stringify(options.updateOnlyOn),\n    JSON.stringify(sources),\n  ]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTrackPublications()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport { ConnectionState, Room } from 'livekit-client';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal/useObservableState';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n *\n * @remarks\n * Message history is not persisted and will be lost if the component is refreshed.\n * You may want to persist message history in the browser, a cache or a database.\n *\n * @returns An object containing:\n * - `chatMessages` - Array of received chat messages\n * - `send` - Function to send a new message\n * - `isSending` - Boolean indicating if a message is currently being sent\n *\n * @example\n * ```tsx\n * function ChatComponent() {\n *   const { chatMessages, send, isSending } = useChat();\n *\n *   return (\n *     <div>\n *       {chatMessages.map((msg) => (\n *         <div key={msg.timestamp}>\n *           {msg.from?.identity}: {msg.message}\n *         </div>\n *       ))}\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\n *         Send Message\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * @public\n */\nexport function useChat(options?: ChatOptions & { room?: Room }) {\n  const room = useEnsureRoom(options?.room);\n  const connectionState = useConnectionState(room);\n  const isDisconnected = React.useMemo(\n    () => connectionState === ConnectionState.Disconnected,\n    [connectionState],\n  ); // used to reset the messages on room disconnect\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\n    () => setupChat(room, options),\n    [room, options, isDisconnected],\n  );\n  const isSending = useObservableState(setup.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\n\n  return { send: setup.send, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant } from 'livekit-client';\nimport type { Participant, Room } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport interface UseIsEncryptedOptions {\n  room?: Room;\n}\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\n  const p = useEnsureParticipant(participant);\n\n  const room = useEnsureRoom(options.room);\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport function useTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n}\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport function useMultibandTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...multibandDefaults, ...options };\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\n    new Array(opts.bands).fill(0),\n  );\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      setFrequencyBands((val) => val.slice().fill(0));\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(opts.loPass, opts.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\n      const totalBins = normalizedFrequencies.length;\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        // Use proportional distribution to evenly divide bins across bands\n        const startIndex = Math.floor((i * totalBins) / opts.bands);\n        const endIndex = Math.floor(((i + 1) * totalBins) / opts.bands);\n        const chunk = normalizedFrequencies.slice(startIndex, endIndex);\n        const chunkLength = chunk.length;\n        if (chunkLength === 0) {\n          chunks.push(0);\n        } else {\n          const summedVolumes = chunk.reduce((acc, val) => (acc += val), 0);\n          chunks.push(summedVolumes / chunkLength);\n        }\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n}\n\n/**\n * @alpha\n */\nexport interface AudioWaveformOptions {\n  barCount?: number;\n  volMultiplier?: number;\n  updateInterval?: number;\n}\n\nconst waveformDefaults = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20,\n} as const satisfies AudioWaveformOptions;\n\n/**\n * @alpha\n */\nexport function useAudioWaveform(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: AudioWaveformOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...waveformDefaults, ...options };\n\n  const aggregateWave = React.useRef(new Float32Array());\n  const timeRef = React.useRef(performance.now());\n  const updates = React.useRef(0);\n  const [bars, setBars] = React.useState<number[]>([]);\n\n  const onUpdate = React.useCallback((wave: Float32Array) => {\n    setBars(\n      Array.from(\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ),\n    );\n  }, []);\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, {\n      fftSize: getFFTSizeValue(opts.barCount),\n    });\n\n    const bufferLength = getFFTSizeValue(opts.barCount);\n    const dataArray = new Float32Array(bufferLength);\n\n    const update = () => {\n      updateWaveform = requestAnimationFrame(update);\n      analyser.getFloatTimeDomainData(dataArray);\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\n      updates.current += 1;\n\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\n        const newData = dataArray.map((v) => v / updates.current);\n        onUpdate(newData);\n        timeRef.current = performance.now();\n        updates.current = 0;\n      }\n    };\n\n    let updateWaveform = requestAnimationFrame(update);\n\n    return () => {\n      cleanup();\n      cancelAnimationFrame(updateWaveform);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\n\n  return {\n    bars,\n  };\n}\n\nfunction getFFTSizeValue(x: number) {\n  if (x < 32) return 32;\n  else return pow2ceil(x);\n}\n\n// function sigmoid(x: number, k = 2, s = 0) {\n//   return 1 / (1 + Math.exp(-(x - s) / k));\n// }\n\nfunction pow2ceil(v: number) {\n  let p = 2;\n  while ((v >>= 1)) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction filterData(audioData: Float32Array, numSamples: number) {\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\n  const filteredData = new Float32Array(numSamples);\n  for (let i = 0; i < numSamples; i++) {\n    const blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\n  }\n  return filteredData;\n}\n\n// function normalizeData(audioData: Float32Array) {\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\n//   return audioData.map((n) => n * multiplier);\n// }\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Room, Track } from 'livekit-client';\nimport { useMaybeParticipantContext } from '../context';\nimport { useParticipants } from './useParticipants';\n\ntype UseParticipantTracksOptions = {\n  participantIdentity?: string;\n  room?: Room;\n};\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks<TrackSource extends Track.Source>(\n  sources: Array<TrackSource>,\n  optionsOrParticipantIdentity:\n    | UseParticipantTracksOptions\n    | UseParticipantTracksOptions['participantIdentity'] = {},\n): Array<TrackReference> {\n  let participantIdentity: UseParticipantTracksOptions['participantIdentity'];\n  let room: UseParticipantTracksOptions['room'];\n  if (typeof optionsOrParticipantIdentity === 'string') {\n    participantIdentity = optionsOrParticipantIdentity;\n  } else {\n    participantIdentity = optionsOrParticipantIdentity?.participantIdentity;\n    room = optionsOrParticipantIdentity?.room;\n  }\n\n  const participantContext = useMaybeParticipantContext();\n  const participants = useParticipants({ room, updateOnlyOn: [] });\n\n  const p = React.useMemo(() => {\n    if (participantIdentity) {\n      return participants.find((p) => p.identity === participantIdentity);\n    }\n    return participantContext;\n  }, [participantIdentity, participants, participantContext]);\n\n  const observable = React.useMemo(() => {\n    if (!p) {\n      return undefined;\n    }\n    return participantTracksObservable(p, { sources });\n  }, [p, JSON.stringify(sources)]);\n\n  const trackRefs = useObservableState(observable, [] as Array<TrackReference>);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n * @deprecated this is an internal hook that's only used by deprecated APIs\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport {\n  ParticipantAgentAttributes,\n  type ReceivedTranscriptionSegment,\n  type TrackReference,\n} from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\nimport { AgentState } from './useAgent';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = ParticipantAgentAttributes.AgentState;\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState, Room } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/** @beta */\nexport type UseTextStreamOptions = {\n  room?: Room;\n};\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string, options?: UseTextStreamOptions) {\n  const room = useEnsureRoom(options?.room);\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic, ParticipantAgentAttributes } from '@livekit/components-core';\nimport { Room } from 'livekit-client';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  room?: Room;\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION, { room: opts?.room });\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(\n                stream.streamInfo.attributes?.[ParticipantAgentAttributes.TranscribedTrackId] ?? '',\n              )\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n","import { Mutex, type Room } from 'livekit-client';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { log } from '@livekit/components-core';\n\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\n\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\n\n/** @public */\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\n};\n\n/**\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\n * running. This hook sequentializes these two operations, so they always happen in order and\n * never overlap.\n *\n * @example\n * ```ts\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\n *\n * // Connecting to a room:\n * useEffect(() => {\n *   connect();\n *   return () => disconnect();\n * }, [connect, disconnect]);\n * ```\n *\n * @public\n */\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\n  room: R,\n): UseSequentialRoomConnectDisconnectResults<R> {\n  const connectDisconnectQueueRef = useRef<\n    Array<\n      | {\n          type: 'connect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.connect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\n          reject: (err: Error) => void;\n        }\n      | {\n          type: 'disconnect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.disconnect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\n          reject: (err: Error) => void;\n        }\n    >\n  >([]);\n\n  // Process room connection / disconnection events and execute them in series\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\n  // events\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\n  const processConnectsAndDisconnects = useCallback(async () => {\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\n      while (true) {\n        const message = connectDisconnectQueueRef.current.pop();\n        if (!message) {\n          unlock();\n          break;\n        }\n\n        switch (message.type) {\n          case 'connect':\n            await message.room\n              .connect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n          case 'disconnect':\n            await message.room\n              .disconnect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n        }\n      }\n    });\n  }, []);\n\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\n  const checkRoomThreshold = useCallback((now: Date) => {\n    let roomChangesInThreshold = 0;\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        roomChangesInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\n      );\n    }\n  }, []);\n\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\n  useEffect(() => {\n    connectDisconnectQueueRef.current = [];\n\n    const now = new Date();\n    roomChangedTimesRef.current.push(now);\n    checkRoomThreshold(now);\n  }, [room, checkRoomThreshold]);\n\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\n    let connectDisconnectsInThreshold = 0;\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\n      const isWithinThreshold =\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        connectDisconnectsInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\n      );\n    }\n  }, []);\n\n  const connect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called connect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  const disconnect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called discconnect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  return {\n    connect: room ? connect : null,\n    disconnect: room ? disconnect : null,\n  } as UseSequentialRoomConnectDisconnectResults<R>;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import {\n  ConnectionState,\n  LocalTrackPublication,\n  ParticipantEvent,\n  ParticipantKind,\n  RemoteParticipant,\n  RoomEvent,\n  Track,\n  Participant,\n} from 'livekit-client';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { EventEmitter } from 'events';\nimport * as React from 'react';\nimport { ParticipantAgentAttributes, TrackReference } from '@livekit/components-core';\n\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { UseSessionReturn } from './useSession';\nimport { useMaybeSessionContext } from '../context';\nimport { useParticipantInfo } from './useParticipantInfo';\n\n// FIXME: make this 10 seconds once room dispatch booting info is discoverable\nconst DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS = 20_000;\n\n/** @see https://github.com/livekit/agents/blob/65170238db197f62f479eb7aaef1c0e18bfad6e7/livekit-agents/livekit/agents/voice/events.py#L97 */\ntype AgentSdkStates = 'initializing' | 'idle' | 'listening' | 'thinking' | 'speaking';\n\n/**\n * State representing the current status of the agent, whether it is ready for speach, etc\n *\n * For most agents (which have the preconnect audio buffer feature enabled), this is the lifecycle:\n *   connecting  pre-connect-buffering  initializing/listening/thinking/speaking\n *\n * For agents without the preconnect audio feature enabled:\n *   connecting  initializing  idle/listening/thinking/speaking\n *\n * If an agent fails to connect:\n *   connecting  pre-connect-buffering/initializing  failed\n *\n * Legacy useVoiceAssistant hook:\n *   disconnected  connecting  initializing  listening/thinking/speaking\n *\n * @beta\n * */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'pre-connect-buffering'\n  | 'failed'\n  | AgentSdkStates;\n\n/** @beta */\nexport enum AgentEvent {\n  CameraChanged = 'cameraChanged',\n  MicrophoneChanged = 'microphoneChanged',\n  StateChanged = 'stateChanged',\n}\n\n/** @beta */\nexport type AgentCallbacks = {\n  [AgentEvent.CameraChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.MicrophoneChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.StateChanged]: (newAgentState: AgentState) => void;\n};\n\ntype AgentStateCommon = {\n  // FIXME: maybe add some sort of schema to this?\n  attributes: Participant['attributes'];\n\n  internal: {\n    emitter: TypedEventEmitter<AgentCallbacks>;\n\n    agentParticipant: RemoteParticipant | null;\n    workerParticipant: RemoteParticipant | null;\n  };\n};\n\ntype AgentStateAvailable = AgentStateCommon & {\n  state: 'listening' | 'thinking' | 'speaking';\n  failureReasons: null;\n\n  /** The agent's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: true;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStatePreConnectBuffering = AgentStateCommon & {\n  state: 'pre-connect-buffering';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateUnAvailable = AgentStateCommon & {\n  state: 'initializing' | 'idle';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateConnecting = AgentStateCommon & {\n  state: 'connecting';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateDisconnected = AgentStateCommon & {\n  state: 'disconnected';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateFailed = AgentStateCommon & {\n  state: 'failed';\n  failureReasons: Array<string>;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentActions = {\n  /** Returns a promise that resolves once the agent is connected and available for user input */\n  waitUntilConnected: (signal?: AbortSignal) => Promise<void>;\n\n  /**\n   * Returns a promise that resolves once the client could be listening for user speech (`canListen` is true)\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  waitUntilCouldBeListening: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the client has disconnected from the agent either for an expected or unexpected reason. */\n  waitUntilFinished: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the agent has published a camera track */\n  waitUntilCamera: (signal?: AbortSignal) => Promise<TrackReference>;\n\n  /** Returns a promise that resolves once the agent has published a microphone track */\n  waitUntilMicrophone: (signal?: AbortSignal) => Promise<TrackReference>;\n};\n\ntype AgentStateCases =\n  | AgentStateConnecting\n  | AgentStateDisconnected\n  | AgentStateAvailable\n  | AgentStatePreConnectBuffering\n  | AgentStateUnAvailable\n  | AgentStateFailed;\n\n/** @beta */\nexport type UseAgentReturn = AgentStateCases & AgentActions;\n\nconst generateDerivedStateValues = <State extends AgentState>(state: State) =>\n  ({\n    isConnected: state === 'listening' || state === 'thinking' || state === 'speaking',\n    canListen:\n      state === 'pre-connect-buffering' ||\n      state === 'listening' ||\n      state === 'thinking' ||\n      state === 'speaking',\n    isFinished: state === 'disconnected' || state === 'failed',\n    isPending: state === 'connecting' || state === 'initializing' || state === 'idle',\n  }) as {\n    isConnected: State extends 'listening' | 'thinking' | 'speaking' ? true : false;\n    canListen: State extends 'pre-connect-buffering' | 'listening' | 'thinking' | 'speaking'\n      ? true\n      : false;\n    isFinished: State extends 'disconnected' | 'failed' ? true : false;\n    isPending: State extends 'connecting' | 'initializing' | 'idle' ? true : false;\n  };\n\n/** Internal hook used by useSession to store global agent state */\nexport const useAgentTimeoutIdStore = (): {\n  agentTimeoutFailureReason: string | null;\n  startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n  clearAgentTimeout: () => void;\n  clearAgentTimeoutFailureReason: () => void;\n  updateAgentTimeoutState: (agentState: AgentState) => void;\n  updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n} => {\n  const [agentTimeoutFailureReason, setAgentTimeoutFailureReason] = React.useState<string | null>(\n    null,\n  );\n  const [agentTimeoutId, setAgentTimeoutId] = React.useState<ReturnType<typeof setTimeout> | null>(\n    null,\n  );\n\n  const agentStateRef = React.useRef<AgentState>('connecting');\n  const agentParticipantExistsRef = React.useRef(false);\n\n  const startAgentConnectedTimeout = (agentConnectTimeoutMilliseconds?: number) => {\n    return setTimeout(() => {\n      if (!agentParticipantExistsRef.current) {\n        setAgentTimeoutFailureReason('Agent did not join the room.');\n        return;\n      }\n\n      const { isConnected } = generateDerivedStateValues(agentStateRef.current);\n      if (!isConnected) {\n        setAgentTimeoutFailureReason('Agent joined the room but did not complete initializing.');\n        return;\n      }\n    }, agentConnectTimeoutMilliseconds ?? DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS);\n  };\n\n  return {\n    agentTimeoutFailureReason,\n    startAgentTimeout: React.useCallback(\n      (agentConnectTimeoutMilliseconds?: number) => {\n        if (agentTimeoutId) {\n          clearTimeout(agentTimeoutId);\n        }\n\n        setAgentTimeoutFailureReason(null);\n        setAgentTimeoutId(startAgentConnectedTimeout(agentConnectTimeoutMilliseconds));\n        agentStateRef.current = 'connecting';\n        agentParticipantExistsRef.current = false;\n      },\n      [agentTimeoutId],\n    ),\n    clearAgentTimeout: React.useCallback(() => {\n      if (agentTimeoutId) {\n        clearTimeout(agentTimeoutId);\n      }\n\n      setAgentTimeoutFailureReason(null);\n      setAgentTimeoutId(null);\n      agentStateRef.current = 'connecting';\n      agentParticipantExistsRef.current = false;\n    }, [agentTimeoutId]),\n    clearAgentTimeoutFailureReason: React.useCallback(() => {\n      setAgentTimeoutFailureReason(null);\n    }, []),\n\n    updateAgentTimeoutState: React.useCallback((agentState: AgentState) => {\n      agentStateRef.current = agentState;\n    }, []),\n    updateAgentTimeoutParticipantExists: React.useCallback((agentParticipantExists: boolean) => {\n      agentParticipantExistsRef.current = agentParticipantExists;\n    }, []),\n  };\n};\n\ntype SessionStub = Pick<UseSessionReturn, 'connectionState' | 'room' | 'internal'>;\n\n/** Internal hook used by useAgent which generates a function that when called, will return a\n * promise which resolves when agent.isAvailable is enabled. */\nfunction useAgentWaitUntilDerivedStates(\n  emitter: TypedEventEmitter<AgentCallbacks>,\n  state: AgentState,\n) {\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isConnected } = generateDerivedStateValues(stateRef.current);\n      if (isConnected) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isConnected } = generateDerivedStateValues(state);\n          if (!isConnected) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilConnected - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilCouldBeListening = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { canListen } = generateDerivedStateValues(stateRef.current);\n      if (canListen) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { canListen } = generateDerivedStateValues(state);\n          if (!canListen) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCouldBeListening - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilFinished = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isFinished } = generateDerivedStateValues(stateRef.current);\n      if (isFinished) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isFinished } = generateDerivedStateValues(state);\n          if (!isFinished) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilFinished - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished };\n}\n\n/**\n * useAgent encapculates all agent state, normalizing some quirks around how LiveKit Agents work.\n * @beta\n */\nexport function useAgent(session?: SessionStub): UseAgentReturn {\n  const sessionFromContext = useMaybeSessionContext();\n  session = session ?? sessionFromContext;\n  if (!session) {\n    throw new Error(\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\n    );\n  }\n\n  const {\n    room,\n    internal: {\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    },\n  } = session;\n\n  const emitter = React.useMemo(() => new EventEmitter() as TypedEventEmitter<AgentCallbacks>, []);\n\n  const roomRemoteParticipants = useRemoteParticipants({ room });\n\n  const agentParticipant = React.useMemo(() => {\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n      ) ?? null\n    );\n  }, [roomRemoteParticipants]);\n  const workerParticipant = React.useMemo(() => {\n    if (!agentParticipant) {\n      return null;\n    }\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agentParticipant.identity,\n      ) ?? null\n    );\n  }, [agentParticipant, roomRemoteParticipants]);\n\n  // 1. Listen for agent participant attribute changes\n  const [agentParticipantAttributes, setAgentParticipantAttributes] = React.useState<\n    Participant['attributes']\n  >(agentParticipant?.attributes ?? {});\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const handleAttributesChanged = (attributes: UseAgentReturn['attributes']) => {\n      setAgentParticipantAttributes(attributes);\n    };\n\n    agentParticipant.on(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    return () => {\n      agentParticipant.off(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    };\n  }, [agentParticipant, emitter]);\n\n  // 2. Listen for track updates\n  const agentTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: agentParticipant?.identity,\n  });\n  const workerTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: workerParticipant?.identity,\n  });\n\n  const videoTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Camera) ??\n      workerTracks.find((t) => t.source === Track.Source.Camera),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.CameraChanged, videoTrack);\n  }, [emitter, videoTrack]);\n\n  const audioTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n      workerTracks.find((t) => t.source === Track.Source.Microphone),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.MicrophoneChanged, audioTrack);\n  }, [emitter, audioTrack]);\n\n  // Listen for room connection state updates\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  // When the agent participant connects, reset the timeout failure state\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    clearAgentTimeoutFailureReason();\n  }, [agentParticipant]);\n\n  // If the agent participant disconnects in the middle of a conversation unexpectedly, mark that as an explicit failure\n  const [agentDisconnectedFailureReason, setAgentDisconnectedFailureReason] = React.useState<\n    string | null\n  >(null);\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const onParticipantDisconnect = (participant: RemoteParticipant) => {\n      if (participant.identity !== agentParticipant?.identity) {\n        return;\n      }\n      setAgentDisconnectedFailureReason('Agent left the room unexpectedly.');\n    };\n\n    room.on(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n\n    return () => {\n      room.off(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n    };\n  }, [agentParticipant, room]);\n\n  React.useEffect(() => {\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      return;\n    }\n    // Clear the agent disconnect failure state when the room disconnects\n    setAgentDisconnectedFailureReason(null);\n  }, [roomConnectionState]);\n\n  const [localMicTrack, setLocalMicTrack] = React.useState<LocalTrackPublication | null>(\n    () => room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null,\n  );\n  React.useEffect(() => {\n    const handleLocalParticipantTrackPublished = () => {\n      setLocalMicTrack(room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null);\n    };\n    const handleLocalParticipantTrackUnPublished = () => {\n      setLocalMicTrack(null);\n    };\n\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackPublished,\n      handleLocalParticipantTrackPublished,\n    );\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackUnpublished,\n      handleLocalParticipantTrackUnPublished,\n    );\n    return () => {\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackPublished,\n        handleLocalParticipantTrackPublished,\n      );\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackUnpublished,\n        handleLocalParticipantTrackUnPublished,\n      );\n    };\n  }, [room.localParticipant]);\n\n  const failureReasons = React.useMemo(() => {\n    const reasons = [];\n    if (agentTimeoutFailureReason) {\n      reasons.push(agentTimeoutFailureReason);\n    }\n    if (agentDisconnectedFailureReason) {\n      reasons.push(agentDisconnectedFailureReason);\n    }\n    return reasons;\n  }, [agentTimeoutFailureReason, agentDisconnectedFailureReason]);\n\n  const state = React.useMemo(() => {\n    if (failureReasons.length > 0) {\n      return 'failed';\n    }\n\n    let state: AgentState = 'disconnected';\n\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      state = 'connecting';\n    }\n\n    // If the microphone preconnect buffer is active, then a special 'pre-connect-buffering' state\n    // is set\n    if (localMicTrack) {\n      state = 'pre-connect-buffering';\n    }\n\n    if (agentParticipant && agentParticipantAttributes[ParticipantAgentAttributes.AgentState]) {\n      state = agentParticipantAttributes[ParticipantAgentAttributes.AgentState] as AgentSdkStates;\n    }\n\n    return state;\n  }, [\n    failureReasons,\n    roomConnectionState,\n    localMicTrack,\n    agentParticipant,\n    agentParticipantAttributes,\n  ]);\n\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.StateChanged, state);\n    updateAgentTimeoutState(state);\n  }, [emitter, state]);\n  React.useEffect(() => {\n    updateAgentTimeoutParticipantExists(agentParticipant !== null);\n  }, [agentParticipant]);\n\n  // When the session room begins connecting, start the agent timeout\n  const isSessionDisconnected = session.connectionState === 'disconnected';\n  React.useEffect(() => {\n    if (isSessionDisconnected) {\n      return;\n    }\n\n    startAgentTimeout(agentConnectTimeoutMilliseconds);\n    return () => {\n      clearAgentTimeout();\n    };\n  }, [isSessionDisconnected, agentConnectTimeoutMilliseconds]);\n\n  const {\n    identity: agentParticipantIdentity,\n    name: agentParticipantName,\n    metadata: agentParticipantMetadata,\n  } = useParticipantInfo({ participant: agentParticipant ?? undefined });\n\n  const agentState: AgentStateCases = React.useMemo(() => {\n    const common: AgentStateCommon = {\n      attributes: agentParticipantAttributes,\n\n      internal: {\n        agentParticipant,\n        workerParticipant,\n        emitter,\n      },\n    };\n\n    switch (state) {\n      case 'disconnected':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'connecting':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'initializing':\n      case 'idle':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'pre-connect-buffering':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'listening':\n      case 'thinking':\n      case 'speaking':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'failed':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state: 'failed',\n          ...generateDerivedStateValues('failed'),\n          failureReasons,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n    }\n  }, [\n    agentParticipantIdentity,\n    agentParticipantName,\n    agentParticipantMetadata,\n    agentParticipantAttributes,\n    emitter,\n    agentParticipant,\n    state,\n    videoTrack,\n    audioTrack,\n  ]);\n\n  const { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished } =\n    useAgentWaitUntilDerivedStates(emitter, state);\n\n  const waitUntilCamera = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (camera: TrackReference | undefined) => {\n          if (!camera) {\n            return;\n          }\n          cleanup();\n          resolve(camera);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCamera - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.CameraChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.CameraChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilMicrophone = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (microphone: TrackReference | undefined) => {\n          if (!microphone) {\n            return;\n          }\n          cleanup();\n          resolve(microphone);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilMicrophone - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.MicrophoneChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.MicrophoneChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return React.useMemo(() => {\n    return {\n      ...agentState,\n      waitUntilConnected,\n      waitUntilCouldBeListening,\n      waitUntilFinished,\n      waitUntilCamera,\n      waitUntilMicrophone,\n    };\n  }, [\n    agentState,\n    waitUntilConnected,\n    waitUntilCouldBeListening,\n    waitUntilFinished,\n    waitUntilCamera,\n    waitUntilMicrophone,\n  ]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport {\n  Room,\n  RoomEvent,\n  ConnectionState,\n  TrackPublishOptions,\n  Track,\n  TokenSourceConfigurable,\n  TokenSourceFixed,\n  TokenSourceFetchOptions,\n  RoomConnectOptions,\n  decodeTokenPayload,\n} from 'livekit-client';\nimport { EventEmitter } from 'events';\n\nimport { useMaybeRoomContext } from '../context';\nimport { AgentState, useAgent, useAgentTimeoutIdStore } from './useAgent';\nimport { TrackReference } from '@livekit/components-core';\nimport { useLocalParticipant } from './useLocalParticipant';\n\n/** @beta */\nexport enum SessionEvent {\n  ConnectionStateChanged = 'connectionStateChanged',\n  /**\n   * Emits when an error is encountered while attempting to create a track.\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * args: (error: Error, kind: MediaDeviceKind)\n   */\n  MediaDevicesError = 'mediaDevicesError',\n  /**\n   * Emits when an error is received while decrypting frame received frame information.\n   * args: (error: Error)\n   */\n  EncryptionError = 'encryptionError',\n}\n\n/** @beta */\nexport type SessionCallbacks = {\n  [SessionEvent.ConnectionStateChanged]: (newAgentConnectionState: ConnectionState) => void;\n  [SessionEvent.MediaDevicesError]: (error: Error) => void;\n  [SessionEvent.EncryptionError]: (error: Error) => void;\n};\n\n/** @beta */\nexport type SessionConnectOptions = {\n  /** Optional abort signal which if triggered will terminate connecting even if it isn't complete */\n  signal?: AbortSignal;\n\n  tracks?: {\n    microphone?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n    camera?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n    screenShare?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n  };\n\n  /** Options for Room.connect(.., .., opts) */\n  roomConnectOptions?: RoomConnectOptions;\n};\n\n/** @beta */\nexport type SwitchActiveDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\ntype SessionStateCommon = {\n  room: Room;\n  internal: {\n    emitter: TypedEventEmitter<SessionCallbacks>;\n    tokenSource: TokenSourceConfigurable | TokenSourceFixed;\n    agentConnectTimeoutMilliseconds?: number;\n\n    agentTimeoutFailureReason: string | null;\n    startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n    clearAgentTimeout: () => void;\n    clearAgentTimeoutFailureReason: () => void;\n    updateAgentTimeoutState: (agentState: AgentState) => void;\n    updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n  };\n};\n\ntype SessionStateConnecting = SessionStateCommon & {\n  connectionState: ConnectionState.Connecting;\n  isConnected: false;\n\n  local: {\n    cameraTrack: undefined;\n    microphoneTrack: undefined;\n    screenShareTrack: undefined;\n  };\n};\n\ntype SessionStateConnected = SessionStateCommon & {\n  connectionState:\n    | ConnectionState.Connected\n    | ConnectionState.Reconnecting\n    | ConnectionState.SignalReconnecting;\n  isConnected: true;\n\n  local: {\n    cameraTrack?: TrackReference;\n    microphoneTrack?: TrackReference;\n    screenShareTrack?: TrackReference;\n  };\n};\n\ntype SessionStateDisconnected = SessionStateCommon & {\n  connectionState: ConnectionState.Disconnected;\n  isConnected: false;\n\n  local: {\n    cameraTrack: undefined;\n    microphoneTrack: undefined;\n    screenShareTrack: undefined;\n  };\n};\n\ntype SessionActions = {\n  /** Returns a promise that resolves once the room connects. */\n  waitUntilConnected: (signal?: AbortSignal) => void;\n  /** Returns a promise that resolves once the room disconnects */\n  waitUntilDisconnected: (signal?: AbortSignal) => void;\n\n  prepareConnection: () => Promise<void>;\n\n  /** Connect to the underlying room and dispatch any agents */\n  start: (options?: SessionConnectOptions) => Promise<void>;\n\n  /** Disconnect from the underlying room */\n  end: () => Promise<void>;\n};\n\n/** @beta */\nexport type UseSessionReturn = (\n  | SessionStateConnecting\n  | SessionStateConnected\n  | SessionStateDisconnected\n) &\n  SessionActions;\n\ntype UseSessionCommonOptions = {\n  room?: Room;\n\n  /**\n   * Amount of time in milliseonds the system will wait for an agent to join the room, before\n   * transitioning to the \"failure\" state.\n   */\n  agentConnectTimeoutMilliseconds?: number;\n};\n\ntype UseSessionConfigurableOptions = UseSessionCommonOptions & TokenSourceFetchOptions;\ntype UseSessionFixedOptions = UseSessionCommonOptions;\n\n/**\n * Given two TokenSourceFetchOptions values, check to see if they are deep equal.\n *\n * FIXME: swap this for an import from livekit-client once\n * https://github.com/livekit/client-sdk-js/pull/1733 is merged and published!\n * */\nfunction areTokenSourceFetchOptionsEqual(a: TokenSourceFetchOptions, b: TokenSourceFetchOptions) {\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]) as Set<\n    keyof TokenSourceFetchOptions\n  >;\n\n  for (const key of allKeysSet) {\n    switch (key) {\n      case 'roomName':\n      case 'participantName':\n      case 'participantIdentity':\n      case 'participantMetadata':\n      case 'participantAttributes':\n      case 'agentName':\n      case 'agentMetadata':\n        if (a[key] !== b[key]) {\n          return false;\n        }\n        break;\n      default:\n        // ref: https://stackoverflow.com/a/58009992\n        const exhaustiveCheckedKey: never = key;\n        throw new Error(`Options key ${exhaustiveCheckedKey} not being checked for equality!`);\n    }\n  }\n\n  return true;\n}\n\n/** Internal hook used by useSession to manage creating a function which can be used to wait\n * until the session is in a given state before resolving. */\nfunction useSessionWaitUntilConnectionState(\n  emitter: TypedEventEmitter<SessionCallbacks>,\n  connectionState: UseSessionReturn['connectionState'],\n) {\n  const connectionStateRef = React.useRef(connectionState);\n  React.useEffect(() => {\n    connectionStateRef.current = connectionState;\n  }, [connectionState]);\n\n  const waitUntilConnectionState = React.useCallback(\n    async (state: UseSessionReturn['connectionState'], signal?: AbortSignal) => {\n      if (connectionStateRef.current === state) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const onceEventOccurred = (newState: UseSessionReturn['connectionState']) => {\n          if (newState !== state) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(\n            new Error(\n              `useSession(/* ... */).waitUntilConnectionState(${state}, /* signal */) - signal aborted`,\n            ),\n          );\n        };\n\n        const cleanup = () => {\n          emitter.off(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return waitUntilConnectionState;\n}\n\n/** Internal hook used by useSession to manage creating a function that properly invokes\n * tokenSource.fetch(...) with any fetch options */\nfunction useSessionTokenSourceFetch(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  unstableRestOptions: Exclude<UseSessionConfigurableOptions, keyof UseSessionCommonOptions>,\n) {\n  const isConfigurable = tokenSource instanceof TokenSourceConfigurable;\n\n  const memoizedTokenFetchOptionsRef = React.useRef<TokenSourceFetchOptions | null>(\n    isConfigurable ? unstableRestOptions : null,\n  );\n\n  React.useEffect(() => {\n    if (!isConfigurable) {\n      memoizedTokenFetchOptionsRef.current = null;\n      return;\n    }\n\n    if (\n      memoizedTokenFetchOptionsRef.current !== null &&\n      areTokenSourceFetchOptionsEqual(memoizedTokenFetchOptionsRef.current, unstableRestOptions)\n    ) {\n      return;\n    }\n\n    memoizedTokenFetchOptionsRef.current = unstableRestOptions;\n  }, [isConfigurable, unstableRestOptions]);\n\n  const tokenSourceFetch = React.useCallback(async () => {\n    if (isConfigurable) {\n      if (!memoizedTokenFetchOptionsRef.current) {\n        throw new Error(\n          `AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!`,\n        );\n      }\n      return tokenSource.fetch(memoizedTokenFetchOptionsRef.current);\n    } else {\n      return tokenSource.fetch();\n    }\n  }, [isConfigurable, tokenSource]);\n\n  return tokenSourceFetch;\n}\n\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceConfigurable,\n  options?: UseSessionConfigurableOptions,\n): UseSessionReturn;\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceFixed,\n  options?: UseSessionFixedOptions,\n): UseSessionReturn;\nexport function useSession(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  options: UseSessionConfigurableOptions | UseSessionFixedOptions = {},\n): UseSessionReturn {\n  const { room: optionsRoom, agentConnectTimeoutMilliseconds, ...restOptions } = options;\n\n  const roomFromContext = useMaybeRoomContext();\n  const room = React.useMemo(\n    () => roomFromContext ?? optionsRoom ?? new Room(),\n    [roomFromContext, optionsRoom],\n  );\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<SessionCallbacks>,\n    [],\n  );\n\n  const generateDerivedConnectionStateValues = React.useCallback(\n    <State extends UseSessionReturn['connectionState']>(connectionState: State) =>\n      ({\n        isConnected:\n          connectionState === ConnectionState.Connected ||\n          connectionState === ConnectionState.Reconnecting ||\n          connectionState === ConnectionState.SignalReconnecting,\n      }) as {\n        isConnected: State extends\n          | ConnectionState.Connected\n          | ConnectionState.Reconnecting\n          | ConnectionState.SignalReconnecting\n          ? true\n          : false;\n      },\n    [],\n  );\n\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  React.useEffect(() => {\n    const handleMediaDevicesError = async (error: Error) => {\n      emitter.emit(SessionEvent.MediaDevicesError, error);\n    };\n\n    room.on(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    return () => {\n      room.off(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    };\n  }, [room, emitter]);\n\n  React.useEffect(() => {\n    const handleEncryptionError = async (error: Error) => {\n      emitter.emit(SessionEvent.EncryptionError, error);\n    };\n\n    room.on(RoomEvent.EncryptionError, handleEncryptionError);\n    return () => {\n      room.off(RoomEvent.EncryptionError, handleEncryptionError);\n    };\n  }, [room, emitter]);\n\n  const { localParticipant } = useLocalParticipant({ room });\n  const cameraPublication = localParticipant.getTrackPublication(Track.Source.Camera);\n  const localCamera = React.useMemo(() => {\n    if (!cameraPublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.Camera,\n      participant: localParticipant,\n      publication: cameraPublication,\n    };\n  }, [localParticipant, cameraPublication]);\n  const microphonePublication = localParticipant.getTrackPublication(Track.Source.Microphone);\n  const localMicrophone = React.useMemo(() => {\n    if (!microphonePublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.Microphone,\n      participant: localParticipant,\n      publication: microphonePublication,\n    };\n  }, [localParticipant, microphonePublication]);\n  const screenSharePublication = localParticipant.getTrackPublication(Track.Source.ScreenShare);\n  const localScreenShare = React.useMemo(() => {\n    if (!screenSharePublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.ScreenShare,\n      participant: localParticipant,\n      publication: screenSharePublication,\n    };\n  }, [localParticipant, screenSharePublication]);\n\n  const {\n    agentTimeoutFailureReason,\n    startAgentTimeout,\n    clearAgentTimeout,\n    clearAgentTimeoutFailureReason,\n    updateAgentTimeoutState,\n    updateAgentTimeoutParticipantExists,\n  } = useAgentTimeoutIdStore();\n\n  const sessionInternal: UseSessionReturn['internal'] = React.useMemo(\n    () => ({\n      emitter,\n      tokenSource,\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    }),\n    [\n      emitter,\n      agentConnectTimeoutMilliseconds,\n      tokenSource,\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    ],\n  );\n\n  const conversationState = React.useMemo(():\n    | SessionStateConnecting\n    | SessionStateConnected\n    | SessionStateDisconnected => {\n    const common: SessionStateCommon = {\n      room,\n      internal: sessionInternal,\n    };\n\n    switch (roomConnectionState) {\n      case ConnectionState.Connecting:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Connecting,\n          ...generateDerivedConnectionStateValues(ConnectionState.Connecting),\n\n          local: {\n            cameraTrack: undefined,\n            microphoneTrack: undefined,\n            screenShareTrack: undefined,\n          },\n        };\n\n      case ConnectionState.Connected:\n      case ConnectionState.Reconnecting:\n      case ConnectionState.SignalReconnecting:\n        return {\n          ...common,\n\n          connectionState: roomConnectionState,\n          ...generateDerivedConnectionStateValues(roomConnectionState),\n\n          local: {\n            cameraTrack: localCamera,\n            microphoneTrack: localMicrophone,\n            screenShareTrack: localScreenShare,\n          },\n        };\n\n      case ConnectionState.Disconnected:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Disconnected,\n          ...generateDerivedConnectionStateValues(ConnectionState.Disconnected),\n\n          local: {\n            cameraTrack: undefined,\n            microphoneTrack: undefined,\n            screenShareTrack: undefined,\n          },\n        };\n    }\n  }, [\n    sessionInternal,\n    room,\n    roomConnectionState,\n    localCamera,\n    localMicrophone,\n    generateDerivedConnectionStateValues,\n  ]);\n  React.useEffect(() => {\n    emitter.emit(SessionEvent.ConnectionStateChanged, conversationState.connectionState);\n  }, [emitter, conversationState.connectionState]);\n\n  const waitUntilConnectionState = useSessionWaitUntilConnectionState(\n    emitter,\n    conversationState.connectionState,\n  );\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(\n        ConnectionState.Connected /* FIXME: should I check for other states too? */,\n        signal,\n      );\n    },\n    [waitUntilConnectionState],\n  );\n\n  const waitUntilDisconnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(ConnectionState.Disconnected, signal);\n    },\n    [waitUntilConnectionState],\n  );\n\n  const agent = useAgent(\n    React.useMemo(\n      () => ({\n        connectionState: conversationState.connectionState,\n        room,\n        internal: sessionInternal,\n      }),\n      [conversationState, room, sessionInternal],\n    ),\n  );\n\n  const tokenSourceFetch = useSessionTokenSourceFetch(tokenSource, restOptions);\n\n  const start = React.useCallback(\n    async (connectOptions: SessionConnectOptions = {}) => {\n      const {\n        signal,\n        tracks = { microphone: { enabled: true, publishOptions: { preConnectBuffer: true } } },\n        roomConnectOptions,\n      } = connectOptions;\n\n      await waitUntilDisconnected(signal);\n\n      const onSignalAbort = () => {\n        room.disconnect();\n      };\n      signal?.addEventListener('abort', onSignalAbort);\n\n      let tokenDispatchesAgent = false;\n      await Promise.all([\n        tokenSourceFetch().then(({ serverUrl, participantToken }) => {\n          const participantTokenPayload = decodeTokenPayload(participantToken);\n          const participantTokenAgentDispatchCount =\n            participantTokenPayload.roomConfig?.agents?.length ?? 0;\n          tokenDispatchesAgent = participantTokenAgentDispatchCount > 0;\n\n          return room.connect(serverUrl, participantToken, roomConnectOptions);\n        }),\n\n        // Start microphone (with preconnect buffer) by default\n        tracks.microphone?.enabled\n          ? room.localParticipant.setMicrophoneEnabled(\n              true,\n              undefined,\n              tracks.microphone?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n        tracks.camera?.enabled\n          ? room.localParticipant.setCameraEnabled(\n              true,\n              undefined,\n              tracks.camera?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n        tracks.screenShare?.enabled\n          ? room.localParticipant.setScreenShareEnabled(\n              true,\n              undefined,\n              tracks.screenShare?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n      ]);\n\n      await waitUntilConnected(signal);\n      if (tokenDispatchesAgent) {\n        await agent.waitUntilConnected(signal);\n      }\n\n      signal?.removeEventListener('abort', onSignalAbort);\n    },\n    [room, waitUntilDisconnected, tokenSourceFetch, waitUntilConnected, agent.waitUntilConnected],\n  );\n\n  const end = React.useCallback(async () => {\n    await room.disconnect();\n  }, [room]);\n\n  const prepareConnection = React.useCallback(async () => {\n    const credentials = await tokenSourceFetch();\n    await room.prepareConnection(credentials.serverUrl, credentials.participantToken);\n  }, [tokenSourceFetch, room]);\n  React.useEffect(\n    () => {\n      prepareConnection().catch((err) => {\n        // FIXME: figure out a better logging solution?\n        console.warn('WARNING: Room.prepareConnection failed:', err);\n      });\n    },\n    [\n      /* note: no prepareConnection here, this effect should only ever run once! */\n    ],\n  );\n\n  return React.useMemo(\n    () => ({\n      ...conversationState,\n\n      waitUntilConnected,\n      waitUntilDisconnected,\n\n      prepareConnection,\n      start,\n      end,\n    }),\n    [conversationState, waitUntilConnected, waitUntilDisconnected, prepareConnection, start, end],\n  );\n}\n","import * as React from 'react';\nimport TypedEventEmitter, { EventMap } from 'typed-emitter';\n\n/** @public */\nexport function useEvents<\n  Emitter extends TypedEventEmitter<EventMap>,\n  EmitterEventMap extends Emitter extends TypedEventEmitter<infer EM> ? EM : never,\n  Event extends Parameters<Emitter['on']>[0],\n  Callback extends EmitterEventMap[Event],\n>(\n  instance: Emitter | { internal: { emitter: Emitter } } | null | undefined,\n  event: Event,\n  handlerFn: Callback | undefined,\n  dependencies?: React.DependencyList,\n) {\n  const fallback = React.useMemo(() => () => {}, []);\n  const wrappedCallback = React.useCallback(handlerFn ?? fallback, dependencies ?? []);\n  const callback = dependencies ? wrappedCallback : handlerFn;\n\n  const emitter = React.useMemo(() => {\n    if (!instance) {\n      return null;\n    }\n    if ('internal' in instance) {\n      return instance.internal.emitter;\n    }\n    return instance;\n  }, [instance]);\n\n  React.useEffect(() => {\n    if (!emitter || !callback) {\n      return;\n    }\n    emitter.on(event, callback);\n    return () => {\n      emitter.off(event, callback);\n    };\n  }, [emitter, event, callback]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { SendTextOptions } from 'livekit-client';\nimport { EventEmitter } from 'events';\nimport {\n  ReceivedMessage,\n  ReceivedChatMessage,\n  TextStreamData,\n  ReceivedUserTranscriptionMessage,\n  ReceivedAgentTranscriptionMessage,\n} from '@livekit/components-core';\n\nimport { useAgent } from './useAgent';\nimport { useTranscriptions } from './useTranscriptions';\nimport { useChat } from './useChat';\nimport { UseSessionReturn } from './useSession';\nimport { useEnsureSession } from '../context';\n\n/** @beta */\nexport type UseSessionMessagesReturn = {\n  messages: Array<ReceivedMessage>;\n\n  /** Is a send operation currently in progress? */\n  isSending: boolean;\n\n  send: (message: string, options?: SendTextOptions) => Promise<ReceivedChatMessage>;\n\n  internal: {\n    emitter: TypedEventEmitter<MessagesCallbacks>;\n  };\n};\n\n/** @beta */\nexport enum MessagesEvent {\n  /**\n   * Emits when a new message is received from a participant\n   * args: (message: ReceivedMessage)\n   */\n  MessageReceived = 'messageReceived',\n}\n\n/** @beta */\nexport type MessagesCallbacks = {\n  [MessagesEvent.MessageReceived]: (message: ReceivedMessage) => void;\n};\n\n/** @beta */\nexport function useSessionMessages(session?: UseSessionReturn): UseSessionMessagesReturn {\n  const { room } = useEnsureSession(session);\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<MessagesCallbacks>,\n    [],\n  );\n\n  const agent = useAgent(session);\n\n  const transcriptions: Array<TextStreamData> = useTranscriptions({ room });\n  const chatOptions = React.useMemo(() => ({ room }), [room]);\n  const chat = useChat(chatOptions);\n\n  const transcriptionMessages: Array<\n    ReceivedUserTranscriptionMessage | ReceivedAgentTranscriptionMessage\n  > = React.useMemo(() => {\n    return transcriptions.map((transcription) => {\n      switch (transcription.participantInfo.identity) {\n        case room.localParticipant.identity:\n          return {\n            type: 'userTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: room.localParticipant,\n          };\n\n        case agent.internal.agentParticipant?.identity:\n        case agent.internal.workerParticipant?.identity:\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from:\n              agent.internal.agentParticipant?.identity === transcription.participantInfo.identity\n                ? agent.internal.agentParticipant\n                : agent.internal.workerParticipant!,\n          };\n\n        default:\n          // FIXME: what should happen if an associated participant is not found?\n          //\n          // For now, just assume it is an agent transcription, since maybe it is from an agent\n          // which disconencted from the room or something like that.\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: Array.from(room.remoteParticipants.values()).find(\n              (p) => p.identity === transcription.participantInfo.identity,\n            ),\n          };\n      }\n    });\n  }, [transcriptions, room]);\n\n  const receivedMessages = React.useMemo(() => {\n    const merged: Array<ReceivedMessage> = [...transcriptionMessages, ...chat.chatMessages];\n    return merged;\n  }, [transcriptionMessages, chat.chatMessages]);\n\n  const messageFirstReceivedTimeMapRef = React.useRef(new Map<ReceivedMessage['id'], Date>());\n  const sortedReceivedMessages = React.useMemo(() => {\n    const now = new Date();\n    for (const message of receivedMessages) {\n      if (messageFirstReceivedTimeMapRef.current.has(message.id)) {\n        continue;\n      }\n\n      messageFirstReceivedTimeMapRef.current.set(message.id, now);\n    }\n\n    return receivedMessages.sort((a, b) => {\n      const aFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(a.id);\n      const bFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(b.id);\n      if (typeof aFirstReceivedAt === 'undefined' || typeof bFirstReceivedAt === 'undefined') {\n        return 0;\n      }\n\n      return aFirstReceivedAt.getTime() - bFirstReceivedAt.getTime();\n    });\n  }, [receivedMessages]);\n\n  const previouslyReceivedMessageIdsRef = React.useRef(new Set());\n  React.useEffect(() => {\n    for (const message of sortedReceivedMessages) {\n      if (previouslyReceivedMessageIdsRef.current.has(message.id)) {\n        continue;\n      }\n\n      previouslyReceivedMessageIdsRef.current.add(message.id);\n      emitter.emit(MessagesEvent.MessageReceived, message);\n    }\n  }, [sortedReceivedMessages]);\n\n  return React.useMemo(\n    () => ({\n      messages: sortedReceivedMessages,\n      send: chat.send,\n      isSending: chat.isSending,\n      internal: { emitter },\n    }),\n    [sortedReceivedMessages, chat.send, chat.isSending],\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}